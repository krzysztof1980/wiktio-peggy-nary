//=========================================================================
//
//  This file was generated by Mouse 1.6.1 at 2015-07-29 07:45:54 GMT
//  from grammar
//    '/home/krzysiek/dev/projects/fiszki/wiktionary-parser/src/main/java/w
//    iktiopeggynary/parser/../../../resources/entry_grammar.txt'.
//
//=========================================================================

package wiktiopeggynary.parser;

import wiktiopeggynary.parser.mouse.Source;

public class WiktionaryParser extends wiktiopeggynary.parser.mouse.ParserBase
{
  final WiktionarySemantics sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public WiktionaryParser()
    {
      sem = new WiktionarySemantics();
      sem.rule = this;
      super.sem = sem;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      if (Dokument()) return true;
      return failure();
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public WiktionarySemantics semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  Dokument = (!KOPF2 Line)* Eintrag EOF ;
  //=====================================================================
  private boolean Dokument()
    {
      begin("Dokument");
      while (Dokument_0());
      if (!Eintrag()) return reject();
      if (!EOF()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Dokument_0 = !KOPF2 Line
  //-------------------------------------------------------------------
  private boolean Dokument_0()
    {
      begin("");
      if (!Dokument_1()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Dokument_1 = !KOPF2
  //-------------------------------------------------------------------
  private boolean Dokument_1()
    {
      begin("","not KOPF2");
      if (KOPF2()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  Eintrag = DeEintrag? OtherLangEintrag* EOF ;
  //=====================================================================
  private boolean Eintrag()
    {
      begin("Eintrag");
      DeEintrag();
      while (OtherLangEintrag());
      if (!EOF()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  OtherLangEintrag = (!DeSpracheKopf Line)+ ;
  //=====================================================================
  private boolean OtherLangEintrag()
    {
      begin("OtherLangEintrag");
      if (!OtherLangEintrag_0()) return reject();
      while (OtherLangEintrag_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  OtherLangEintrag_0 = !DeSpracheKopf Line
  //-------------------------------------------------------------------
  private boolean OtherLangEintrag_0()
    {
      begin("");
      if (!OtherLangEintrag_1()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  OtherLangEintrag_1 = !DeSpracheKopf
  //-------------------------------------------------------------------
  private boolean OtherLangEintrag_1()
    {
      begin("","not DeSpracheKopf");
      if (DeSpracheKopf()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  DeEintrag = DeSpracheKopf DeWortart+ ;
  //=====================================================================
  private boolean DeEintrag()
    {
      begin("DeEintrag");
      if (!DeSpracheKopf()) return reject();
      if (!DeWortart()) return reject();
      while (DeWortart());
      return accept();
    }
  
  //=====================================================================
  //  DeSpracheKopf = KOPF2 Lemma "(" DeSpracheTemplate ")" Space KOPF2
  //    RestOfLine ;
  //=====================================================================
  private boolean DeSpracheKopf()
    {
      begin("DeSpracheKopf");
      if (!KOPF2()) return reject();
      if (!Lemma()) return reject();
      if (!next('(')) return reject();
      if (!DeSpracheTemplate()) return reject();
      if (!next(')')) return reject();
      Space();
      if (!KOPF2()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  DeSpracheTemplate = LT "Sprache" IT "Deutsch" RT ;
  //=====================================================================
  private boolean DeSpracheTemplate()
    {
      begin("DeSpracheTemplate");
      if (!LT()) return reject();
      if (!next("Sprache")) return reject();
      if (!IT()) return reject();
      if (!next("Deutsch")) return reject();
      if (!RT()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Lemma = Letter+ Space {Lemma} ;
  //=====================================================================
  private boolean Lemma()
    {
      begin("Lemma");
      if (!Letter()) return reject();
      while (Letter());
      Space();
      sem.Lemma();
      return accept();
    }
  
  //=====================================================================
  //  DeWortart = (WortartKopf WortartBody / UnknownWortartKopf Line*) ;
  //=====================================================================
  private boolean DeWortart()
    {
      begin("DeWortart");
      if (!DeWortart_0()
       && !DeWortart_1()
         ) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  DeWortart_0 = WortartKopf WortartBody
  //-------------------------------------------------------------------
  private boolean DeWortart_0()
    {
      begin("");
      if (!WortartKopf()) return rejectInner();
      WortartBody();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DeWortart_1 = UnknownWortartKopf Line*
  //-------------------------------------------------------------------
  private boolean DeWortart_1()
    {
      begin("");
      if (!UnknownWortartKopf()) return rejectInner();
      while (Line());
      return acceptInner();
    }
  
  //=====================================================================
  //  WortartKopf = SubstantivKopf {saveEintrag} ;
  //=====================================================================
  private boolean WortartKopf()
    {
      begin("WortartKopf");
      if (!SubstantivKopf()) return reject();
      sem.saveEintrag();
      return accept();
    }
  
  //=====================================================================
  //  WortartBody = MiddleSection TranslationsSection?
  //    ~{WortartBody_fail} ;
  //=====================================================================
  private boolean WortartBody()
    {
      begin("WortartBody");
      if (WortartBody_0()) return accept();
      else sem.WortartBody_fail();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  WortartBody_0 = MiddleSection TranslationsSection?
  //-------------------------------------------------------------------
  private boolean WortartBody_0()
    {
      begin("");
      MiddleSection();
      TranslationsSection();
      return acceptInner();
    }
  
  //=====================================================================
  //  UnknownWortartKopf = KOPF3 WortartTemplate _*+ KOPF3 RestOfLine ;
  //=====================================================================
  private boolean UnknownWortartKopf()
    {
      begin("UnknownWortartKopf");
      if (!KOPF3()) return reject();
      if (!WortartTemplate()) return reject();
      while (!KOPF3())
        if (!next()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  WortartTemplate = LT "Wortart" IT TemplateAttr IT "Deutsch" RT
  //    {WortartTemplate} ;
  //=====================================================================
  private boolean WortartTemplate()
    {
      begin("WortartTemplate");
      if (!LT()) return reject();
      if (!next("Wortart")) return reject();
      if (!IT()) return reject();
      if (!TemplateAttr()) return reject();
      if (!IT()) return reject();
      if (!next("Deutsch")) return reject();
      if (!RT()) return reject();
      sem.WortartTemplate();
      return accept();
    }
  
  //=====================================================================
  //  SubstantivKopf = KOPF3 SubstantivTemplate SubstantivAttributes
  //    KOPF3 RestOfLine ;
  //=====================================================================
  private boolean SubstantivKopf()
    {
      begin("SubstantivKopf");
      if (!KOPF3()) return reject();
      if (!SubstantivTemplate()) return reject();
      if (!SubstantivAttributes()) return reject();
      if (!KOPF3()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  SubstantivTemplate = LT "Wortart" IT "Substantiv" IT "Deutsch" RT
  //    {createSubstantiv} ;
  //=====================================================================
  private boolean SubstantivTemplate()
    {
      begin("SubstantivTemplate");
      if (!LT()) return reject();
      if (!next("Wortart")) return reject();
      if (!IT()) return reject();
      if (!next("Substantiv")) return reject();
      if (!IT()) return reject();
      if (!next("Deutsch")) return reject();
      if (!RT()) return reject();
      sem.createSubstantiv();
      return accept();
    }
  
  //=====================================================================
  //  SubstantivAttributes = (","? Space SubstantivAttribute)+
  //    ~{SubstantivAttributes_0_fail} / _++ KOPF3 ;
  //=====================================================================
  private boolean SubstantivAttributes()
    {
      begin("SubstantivAttributes");
      if (SubstantivAttributes_0()) return accept();
      else sem.SubstantivAttributes_0_fail();
      if (SubstantivAttributes_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  SubstantivAttributes_0 = (","? Space SubstantivAttribute)+
  //-------------------------------------------------------------------
  private boolean SubstantivAttributes_0()
    {
      begin("");
      if (!SubstantivAttributes_2()) return rejectInner();
      while (SubstantivAttributes_2());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  SubstantivAttributes_1 = _++ KOPF3
  //-------------------------------------------------------------------
  private boolean SubstantivAttributes_1()
    {
      begin("");
      if (KOPF3()) return rejectInner();
      do if (!next()) return rejectInner();
        while (!KOPF3());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  SubstantivAttributes_2 = ","? Space SubstantivAttribute
  //-------------------------------------------------------------------
  private boolean SubstantivAttributes_2()
    {
      begin("");
      next(',');
      Space();
      if (!SubstantivAttribute()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  SubstantivAttribute = Gender {substantivGender} / WortartTemplate
  //    {substantivWortart} / "''adjektivische Deklination" ","? "''"
  //    {substantivAdjDeklination} ;
  //=====================================================================
  private boolean SubstantivAttribute()
    {
      begin("SubstantivAttribute");
      if (Gender())
      { sem.substantivGender(); return accept(); }
      if (WortartTemplate())
      { sem.substantivWortart(); return accept(); }
      if (SubstantivAttribute_0())
      { sem.substantivAdjDeklination(); return accept(); }
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  SubstantivAttribute_0 = "''adjektivische Deklination" ","? "''"
  //-------------------------------------------------------------------
  private boolean SubstantivAttribute_0()
    {
      begin("");
      if (!next("''adjektivische Deklination")) return rejectInner();
      next(',');
      if (!next("''")) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  FlexionTable = FlexionTableKopf FlexionForm+ RT RestOfLine ;
  //=====================================================================
  private boolean FlexionTable()
    {
      begin("FlexionTable");
      if (!FlexionTableKopf()) return reject();
      if (!FlexionForm()) return reject();
      while (FlexionForm());
      if (!RT()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  FlexionTableKopf = LT "Deutsch Substantiv Übersicht" Space
  //    RestOfLine ;
  //=====================================================================
  private boolean FlexionTableKopf()
    {
      begin("FlexionTableKopf");
      if (!LT()) return reject();
      if (!next("Deutsch Substantiv \u00dcbersicht")) return reject();
      Space();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  FlexionForm = "|" (NomSg / NomPl / GenSg / GenPl / DatSg / DatPl /
  //    AkkSg / AkkPl / BadLine) ;
  //=====================================================================
  private boolean FlexionForm()
    {
      begin("FlexionForm");
      if (!next('|')) return reject();
      if (!NomSg()
       && !NomPl()
       && !GenSg()
       && !GenPl()
       && !DatSg()
       && !DatPl()
       && !AkkSg()
       && !AkkPl()
       && !BadLine()
         ) return reject();
      return accept();
    }
  
  //=====================================================================
  //  NomSg = "Nominativ Singular" Space OptDigit Space "="
  //    FlexionVariantList RestOfLine {addNomSg} ;
  //=====================================================================
  private boolean NomSg()
    {
      begin("NomSg");
      if (!next("Nominativ Singular")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addNomSg();
      return accept();
    }
  
  //=====================================================================
  //  NomPl = "Nominativ Plural" Space OptDigit Space "="
  //    FlexionVariantList RestOfLine {addNomPl} ;
  //=====================================================================
  private boolean NomPl()
    {
      begin("NomPl");
      if (!next("Nominativ Plural")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addNomPl();
      return accept();
    }
  
  //=====================================================================
  //  GenSg = "Genitiv Singular" Space OptDigit Space "="
  //    FlexionVariantList RestOfLine {addGenSg} ;
  //=====================================================================
  private boolean GenSg()
    {
      begin("GenSg");
      if (!next("Genitiv Singular")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addGenSg();
      return accept();
    }
  
  //=====================================================================
  //  GenPl = "Genitiv Plural" Space OptDigit Space "="
  //    FlexionVariantList RestOfLine {addGenPl} ;
  //=====================================================================
  private boolean GenPl()
    {
      begin("GenPl");
      if (!next("Genitiv Plural")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addGenPl();
      return accept();
    }
  
  //=====================================================================
  //  DatSg = "Dativ Singular" Space OptDigit Space "="
  //    FlexionVariantList RestOfLine {addDatSg} ;
  //=====================================================================
  private boolean DatSg()
    {
      begin("DatSg");
      if (!next("Dativ Singular")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addDatSg();
      return accept();
    }
  
  //=====================================================================
  //  DatPl = "Dativ Plural" Space OptDigit Space "=" FlexionVariantList
  //    RestOfLine {addDatPl} ;
  //=====================================================================
  private boolean DatPl()
    {
      begin("DatPl");
      if (!next("Dativ Plural")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addDatPl();
      return accept();
    }
  
  //=====================================================================
  //  AkkSg = "Akkusativ Singular" Space OptDigit Space "="
  //    FlexionVariantList RestOfLine {addAkkSg} ;
  //=====================================================================
  private boolean AkkSg()
    {
      begin("AkkSg");
      if (!next("Akkusativ Singular")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addAkkSg();
      return accept();
    }
  
  //=====================================================================
  //  AkkPl = "Akkusativ Plural" Space OptDigit Space "="
  //    FlexionVariantList RestOfLine {addAkkPl} ;
  //=====================================================================
  private boolean AkkPl()
    {
      begin("AkkPl");
      if (!next("Akkusativ Plural")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addAkkPl();
      return accept();
    }
  
  //=====================================================================
  //  FlexionVariantList = Space Phrase (BR Phrase)*
  //    {FlexionVariantList_0} / Space "\u2014" Space
  //    {FlexionVariantList_1} / (!EOL _)* ;
  //=====================================================================
  private boolean FlexionVariantList()
    {
      begin("FlexionVariantList");
      if (FlexionVariantList_0())
      { sem.FlexionVariantList_0(); return accept(); }
      if (FlexionVariantList_1())
      { sem.FlexionVariantList_1(); return accept(); }
      if (FlexionVariantList_2()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  FlexionVariantList_0 = Space Phrase (BR Phrase)*
  //-------------------------------------------------------------------
  private boolean FlexionVariantList_0()
    {
      begin("");
      Space();
      if (!Phrase()) return rejectInner();
      while (FlexionVariantList_3());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  FlexionVariantList_1 = Space "\u2014" Space
  //-------------------------------------------------------------------
  private boolean FlexionVariantList_1()
    {
      begin("");
      Space();
      if (!next('\u2014')) return rejectInner();
      Space();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  FlexionVariantList_2 = (!EOL _)*
  //-------------------------------------------------------------------
  private boolean FlexionVariantList_2()
    {
      begin("");
      while (FlexionVariantList_4());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  FlexionVariantList_3 = BR Phrase
  //-------------------------------------------------------------------
  private boolean FlexionVariantList_3()
    {
      begin("");
      if (!BR()) return rejectInner();
      if (!Phrase()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  FlexionVariantList_4 = !EOL _
  //-------------------------------------------------------------------
  private boolean FlexionVariantList_4()
    {
      begin("");
      if (!FlexionVariantList_5()) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  FlexionVariantList_5 = !EOL
  //-------------------------------------------------------------------
  private boolean FlexionVariantList_5()
    {
      begin("","not EOL");
      if (EOL()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  Gender = LT GenderTemplateArgument RT Space {Gender} ;
  //=====================================================================
  private boolean Gender()
    {
      begin("Gender");
      if (!LT()) return reject();
      if (!GenderTemplateArgument()) return reject();
      if (!RT()) return reject();
      Space();
      sem.Gender();
      return accept();
    }
  
  //=====================================================================
  //  GenderTemplateArgument = "mf" / "f" ("m" / "n") / "n" ("m" / "f") /
  //    "m" / "f" / "n" / "u" ;
  //=====================================================================
  private boolean GenderTemplateArgument()
    {
      begin("GenderTemplateArgument");
      if (next("mf")) return accept();
      if (GenderTemplateArgument_0()) return accept();
      if (GenderTemplateArgument_1()) return accept();
      if (next('m')) return accept();
      if (next('f')) return accept();
      if (next('n')) return accept();
      if (next('u')) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  GenderTemplateArgument_0 = "f" ("m" / "n")
  //-------------------------------------------------------------------
  private boolean GenderTemplateArgument_0()
    {
      begin("");
      if (!next('f')) return rejectInner();
      if (!next('m')
       && !next('n')
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  GenderTemplateArgument_1 = "n" ("m" / "f")
  //-------------------------------------------------------------------
  private boolean GenderTemplateArgument_1()
    {
      begin("");
      if (!next('n')) return rejectInner();
      if (!next('m')
       && !next('f')
         ) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  MiddleSection = (!TranslationsKopf (FlexionTable / Line))* ;
  //=====================================================================
  private boolean MiddleSection()
    {
      begin("MiddleSection");
      while (MiddleSection_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  MiddleSection_0 = !TranslationsKopf (FlexionTable / Line)
  //-------------------------------------------------------------------
  private boolean MiddleSection_0()
    {
      begin("");
      if (!MiddleSection_1()) return rejectInner();
      if (!FlexionTable()
       && !Line()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  MiddleSection_1 = !TranslationsKopf
  //-------------------------------------------------------------------
  private boolean MiddleSection_1()
    {
      begin("","not TranslationsKopf");
      if (TranslationsKopf()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  TranslationsSection = TranslationsKopf (!TranslationsTableKopf
  //    Line)* TranslationsTable (!KopfStart Line)* ;
  //=====================================================================
  private boolean TranslationsSection()
    {
      begin("TranslationsSection");
      if (!TranslationsKopf()) return reject();
      while (TranslationsSection_0());
      if (!TranslationsTable()) return reject();
      while (TranslationsSection_1());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsSection_0 = !TranslationsTableKopf Line
  //-------------------------------------------------------------------
  private boolean TranslationsSection_0()
    {
      begin("");
      if (!TranslationsSection_2()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsSection_1 = !KopfStart Line
  //-------------------------------------------------------------------
  private boolean TranslationsSection_1()
    {
      begin("");
      if (!TranslationsSection_3()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsSection_2 = !TranslationsTableKopf
  //-------------------------------------------------------------------
  private boolean TranslationsSection_2()
    {
      begin("","not TranslationsTableKopf");
      if (TranslationsTableKopf()) return rejectNot();
      return acceptNot();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsSection_3 = !KopfStart
  //-------------------------------------------------------------------
  private boolean TranslationsSection_3()
    {
      begin("","not KopfStart");
      if (KopfStart()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  TranslationsKopf = KOPF4 "Übersetzungen" Space KOPF4 RestOfLine ;
  //=====================================================================
  private boolean TranslationsKopf()
    {
      begin("TranslationsKopf");
      if (!KOPF4()) return reject();
      if (!next("\u00dcbersetzungen")) return reject();
      Space();
      if (!KOPF4()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  TranslationsTable = TranslationsTableKopf (LangTranslations /
  //    DialectTable / !RT Line)*+ RT RestOfLine ;
  //=====================================================================
  private boolean TranslationsTable()
    {
      begin("TranslationsTable");
      if (!TranslationsTableKopf()) return reject();
      while (!RT())
        if (!TranslationsTable_0()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsTable_0 = LangTranslations / DialectTable / !RT Line
  //-------------------------------------------------------------------
  private boolean TranslationsTable_0()
    {
      begin("");
      if (LangTranslations()) return acceptInner();
      if (DialectTable()) return acceptInner();
      if (TranslationsTable_1()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsTable_1 = !RT Line
  //-------------------------------------------------------------------
  private boolean TranslationsTable_1()
    {
      begin("");
      if (!TranslationsTable_2()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsTable_2 = !RT
  //-------------------------------------------------------------------
  private boolean TranslationsTable_2()
    {
      begin("","not RT");
      if (RT()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  TranslationsTableKopf = LT "Ü-Tabelle" Line ;
  //=====================================================================
  private boolean TranslationsTableKopf()
    {
      begin("TranslationsTableKopf");
      if (!LT()) return reject();
      if (!next("\u00dc-Tabelle")) return reject();
      if (!Line()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  LangTranslations = LangLvl Lang ":" Space TranslationMeaning (";"
  //    Space TranslationMeaning)* RestOfLine
  //    {addTranslationsForLanguage} ;
  //=====================================================================
  private boolean LangTranslations()
    {
      begin("LangTranslations");
      if (!LangLvl()) return reject();
      if (!Lang()) return reject();
      if (!next(':')) return reject();
      Space();
      if (!TranslationMeaning()) return reject();
      while (LangTranslations_0());
      if (!RestOfLine()) return reject();
      sem.addTranslationsForLanguage();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  LangTranslations_0 = ";" Space TranslationMeaning
  //-------------------------------------------------------------------
  private boolean LangTranslations_0()
    {
      begin("");
      if (!next(';')) return rejectInner();
      Space();
      if (!TranslationMeaning()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  LangLvl = "*"+ ;
  //=====================================================================
  private boolean LangLvl()
    {
      begin("LangLvl");
      if (!next('*')) return reject();
      while (next('*'));
      return accept();
    }
  
  //=====================================================================
  //  Lang = LT Word RT {Lang} ;
  //=====================================================================
  private boolean Lang()
    {
      begin("Lang");
      if (!LT()) return reject();
      if (!Word()) return reject();
      if (!RT()) return reject();
      sem.Lang();
      return accept();
    }
  
  //=====================================================================
  //  TranslationMeaning = TranslationMeaningNo Translation ("," Space
  //    Translation)* {TranslationMeaning} ;
  //=====================================================================
  private boolean TranslationMeaning()
    {
      begin("TranslationMeaning");
      if (!TranslationMeaningNo()) return reject();
      if (!Translation()) return reject();
      while (TranslationMeaning_0());
      sem.TranslationMeaning();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TranslationMeaning_0 = "," Space Translation
  //-------------------------------------------------------------------
  private boolean TranslationMeaning_0()
    {
      begin("");
      if (!next(',')) return rejectInner();
      Space();
      if (!Translation()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  TranslationMeaningNo = "[" _++ "]" Space {TranslationMeaningNo} ;
  //=====================================================================
  private boolean TranslationMeaningNo()
    {
      begin("TranslationMeaningNo");
      if (!next('[')) return reject();
      if (next(']')) return reject();
      do if (!next()) return reject();
        while (!next(']'));
      Space();
      sem.TranslationMeaningNo();
      return accept();
    }
  
  //=====================================================================
  //  Translation = LT (UeTemplate / UetTemplate) RT Space Gender? (![,;]
  //    !EOL _)* {Translation} ;
  //=====================================================================
  private boolean Translation()
    {
      begin("Translation");
      if (!LT()) return reject();
      if (!UeTemplate()
       && !UetTemplate()
         ) return reject();
      if (!RT()) return reject();
      Space();
      Gender();
      while (Translation_0());
      sem.Translation();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Translation_0 = ![,;] !EOL _
  //-------------------------------------------------------------------
  private boolean Translation_0()
    {
      begin("");
      if (!aheadNotIn(",;")) return rejectInner();
      if (!FlexionVariantList_5()) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  UeTemplate = ("Ü" / "Ü?") IT TemplateAttr IT TemplateAttr (IT
  //    TemplateAttr)? (IT TemplateAttr)? {UeTemplate} ;
  //=====================================================================
  private boolean UeTemplate()
    {
      begin("UeTemplate");
      if (!next('\u00dc')
       && !next("\u00dc?")
         ) return reject();
      if (!IT()) return reject();
      if (!TemplateAttr()) return reject();
      if (!IT()) return reject();
      if (!TemplateAttr()) return reject();
      UeTemplate_0();
      UeTemplate_0();
      sem.UeTemplate();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  UeTemplate_0 = IT TemplateAttr
  //-------------------------------------------------------------------
  private boolean UeTemplate_0()
    {
      begin("");
      if (!IT()) return rejectInner();
      if (!TemplateAttr()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  UetTemplate = ("Üt" / "Üt?") IT TemplateAttr IT TemplateAttr IT
  //    TemplateAttr (IT TemplateAttr)? (IT TemplateAttr)? {UetTemplate}
  //    ;
  //=====================================================================
  private boolean UetTemplate()
    {
      begin("UetTemplate");
      if (!next("\u00dct")
       && !next("\u00dct?")
         ) return reject();
      if (!IT()) return reject();
      if (!TemplateAttr()) return reject();
      if (!IT()) return reject();
      if (!TemplateAttr()) return reject();
      if (!IT()) return reject();
      if (!TemplateAttr()) return reject();
      UeTemplate_0();
      UeTemplate_0();
      sem.UetTemplate();
      return accept();
    }
  
  //=====================================================================
  //  DialectTable = "|Dialekttabelle=" RestOfLine (!RT Line)* ;
  //=====================================================================
  private boolean DialectTable()
    {
      begin("DialectTable");
      if (!next("|Dialekttabelle=")) return reject();
      if (!RestOfLine()) return reject();
      while (TranslationsTable_1());
      return accept();
    }
  
  //=====================================================================
  //  KOPF2 = "==" Space ;
  //=====================================================================
  private boolean KOPF2()
    {
      begin("KOPF2");
      if (!next("==")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  KOPF3 = "===" Space ;
  //=====================================================================
  private boolean KOPF3()
    {
      begin("KOPF3");
      if (!next("===")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  KOPF4 = "====" Space ;
  //=====================================================================
  private boolean KOPF4()
    {
      begin("KOPF4");
      if (!next("====")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  KopfStart = "="+ " " ;
  //=====================================================================
  private boolean KopfStart()
    {
      begin("KopfStart");
      if (!next('=')) return reject();
      while (next('='));
      if (!next(' ')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  LT = "{{" Space ;
  //=====================================================================
  private boolean LT()
    {
      begin("LT");
      if (!next("{{")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  IT = "|" ;
  //=====================================================================
  private boolean IT()
    {
      begin("IT");
      if (!next('|')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  RT = "}}" Space ;
  //=====================================================================
  private boolean RT()
    {
      begin("RT");
      if (!next("}}")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  TemplateAttr = (!(IT / RT) _)+ ;
  //=====================================================================
  private boolean TemplateAttr()
    {
      begin("TemplateAttr");
      if (!TemplateAttr_0()) return reject();
      while (TemplateAttr_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TemplateAttr_0 = !(IT / RT) _
  //-------------------------------------------------------------------
  private boolean TemplateAttr_0()
    {
      begin("");
      if (!TemplateAttr_1()) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TemplateAttr_1 = !(IT / RT)
  //-------------------------------------------------------------------
  private boolean TemplateAttr_1()
    {
      begin("","not IT / RT");
      if (TemplateAttr_2()) return rejectNot();
      return acceptNot();
    }
  
  //-------------------------------------------------------------------
  //  TemplateAttr_2 = IT / RT
  //-------------------------------------------------------------------
  private boolean TemplateAttr_2()
    {
      begin("");
      if (IT()) return acceptInner();
      if (RT()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  BR = "<br" Space "/>" ;
  //=====================================================================
  private boolean BR()
    {
      begin("BR");
      if (!next("<br")) return reject();
      Space();
      if (!next("/>")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Comment = CommentStart _++ CommentEnd Space ;
  //=====================================================================
  private boolean Comment()
    {
      begin("Comment");
      if (!CommentStart()) return reject();
      if (CommentEnd()) return reject();
      do if (!next()) return reject();
        while (!CommentEnd());
      Space();
      return accept();
    }
  
  //=====================================================================
  //  CommentStart = "<!--" ;
  //=====================================================================
  private boolean CommentStart()
    {
      begin("CommentStart");
      if (!next("<!--")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  CommentEnd = "-->" ;
  //=====================================================================
  private boolean CommentEnd()
    {
      begin("CommentEnd");
      if (!next("-->")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Line = _++ EOL ;
  //=====================================================================
  private boolean Line()
    {
      begin("Line");
      if (EOL()) return reject();
      do if (!next()) return reject();
        while (!EOL());
      return accept();
    }
  
  //=====================================================================
  //  BadLine = _++ EOL ;
  //=====================================================================
  private boolean BadLine()
    {
      begin("BadLine");
      if (EOL()) return reject();
      do if (!next()) return reject();
        while (!EOL());
      return accept();
    }
  
  //=====================================================================
  //  EmptyLine = [\n\r]* ;
  //=====================================================================
  private boolean EmptyLine()
    {
      begin("EmptyLine");
      while (nextIn("\n\r"));
      return accept();
    }
  
  //=====================================================================
  //  RestOfLine = _*+ EOL ;
  //=====================================================================
  private boolean RestOfLine()
    {
      begin("RestOfLine");
      while (!EOL())
        if (!next()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Digit = [0-9] ;
  //=====================================================================
  private boolean Digit()
    {
      begin("Digit");
      if (!nextIn('0','9')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  OptDigit = Digit? ;
  //=====================================================================
  private boolean OptDigit()
    {
      begin("OptDigit");
      Digit();
      return accept();
    }
  
  //=====================================================================
  //  Number = Digit+ ;
  //=====================================================================
  private boolean Number()
    {
      begin("Number");
      if (!Digit()) return reject();
      while (Digit());
      return accept();
    }
  
  //=====================================================================
  //  Letter = [a-z] / [A-Z] / [äÄüÜöÖß] ;
  //=====================================================================
  private boolean Letter()
    {
      begin("Letter");
      if (nextIn('a','z')) return accept();
      if (nextIn('A','Z')) return accept();
      if (nextIn("\u00e4\u00c4\u00fc\u00dc\u00f6\u00d6\u00df")) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Word = Letter (Letter / [-'])* ;
  //=====================================================================
  private boolean Word()
    {
      begin("Word");
      if (!Letter()) return reject();
      while (Word_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Word_0 = Letter / [-']
  //-------------------------------------------------------------------
  private boolean Word_0()
    {
      begin("");
      if (Letter()) return acceptInner();
      if (nextIn("-'")) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  Phrase = Word (Space Word)* ;
  //=====================================================================
  private boolean Phrase()
    {
      begin("Phrase");
      if (!Word()) return reject();
      while (Phrase_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Phrase_0 = Space Word
  //-------------------------------------------------------------------
  private boolean Phrase_0()
    {
      begin("");
      Space();
      if (!Word()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Space = " "* ;
  //=====================================================================
  private boolean Space()
    {
      begin("Space");
      while (next(' '));
      return accept();
    }
  
  //=====================================================================
  //  EOF = !_ ;
  //=====================================================================
  private boolean EOF()
    {
      begin("EOF");
      if (!aheadNot()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  EOL = [\r\n]+ / EOF ;
  //=====================================================================
  private boolean EOL()
    {
      begin("EOL");
      if (EOL_0()) return accept();
      if (EOF()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  EOL_0 = [\r\n]+
  //-------------------------------------------------------------------
  private boolean EOL_0()
    {
      begin("");
      if (!nextIn("\r\n")) return rejectInner();
      while (nextIn("\r\n"));
      return acceptInner();
    }
  
}
