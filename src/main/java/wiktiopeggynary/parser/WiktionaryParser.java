//=========================================================================
//
//  This file was generated by Mouse 1.6.1 at 2015-08-02 10:52:01 GMT
//  from grammar
//    '/home/krzysiek/dev/projects/fiszki/wiktionary-parser/src/main/java/w
//    iktiopeggynary/parser/../../../resources/entry_grammar.txt'.
//
//=========================================================================

package wiktiopeggynary.parser;

import wiktiopeggynary.parser.mouse.Source;

public class WiktionaryParser extends wiktiopeggynary.parser.mouse.ParserMemo
{
  final WiktionarySemantics sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public WiktionaryParser()
    {
      sem = new WiktionarySemantics();
      sem.rule = this;
      super.sem = sem;
      caches = cacheList;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      if (Dokument()) return true;
      return failure();
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public WiktionarySemantics semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  Dokument = (!KOPF2 Line)* Eintrag EOF ;
  //=====================================================================
  private boolean Dokument()
    {
      if (saved(Dokument)) return reuse();
      while (Dokument_0());
      if (!Eintrag()) return reject();
      if (!EOF()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Dokument_0 = !KOPF2 Line
  //-------------------------------------------------------------------
  private boolean Dokument_0()
    {
      if (savedInner(Dokument_0)) return reuseInner();
      if (!Dokument_1()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Dokument_1 = !KOPF2
  //-------------------------------------------------------------------
  private boolean Dokument_1()
    {
      if (savedInner(Dokument_1)) return reusePred();
      if (KOPF2()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  Eintrag = DeEintrag? OtherLangEintrag* EOF ;
  //=====================================================================
  private boolean Eintrag()
    {
      if (saved(Eintrag)) return reuse();
      DeEintrag();
      while (OtherLangEintrag());
      if (!EOF()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  OtherLangEintrag = (!DeSpracheKopf Line)+ ;
  //=====================================================================
  private boolean OtherLangEintrag()
    {
      if (saved(OtherLangEintrag)) return reuse();
      if (!OtherLangEintrag_0()) return reject();
      while (OtherLangEintrag_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  OtherLangEintrag_0 = !DeSpracheKopf Line
  //-------------------------------------------------------------------
  private boolean OtherLangEintrag_0()
    {
      if (savedInner(OtherLangEintrag_0)) return reuseInner();
      if (!OtherLangEintrag_1()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  OtherLangEintrag_1 = !DeSpracheKopf
  //-------------------------------------------------------------------
  private boolean OtherLangEintrag_1()
    {
      if (savedInner(OtherLangEintrag_1)) return reusePred();
      if (DeSpracheKopf()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  DeEintrag = DeSpracheKopf DeWortart+ ;
  //=====================================================================
  private boolean DeEintrag()
    {
      if (saved(DeEintrag)) return reuse();
      if (!DeSpracheKopf()) return reject();
      if (!DeWortart()) return reject();
      while (DeWortart());
      return accept();
    }
  
  //=====================================================================
  //  DeSpracheKopf = KOPF2 Lemma "(" DeSpracheTemplate ")" Space KOPF2
  //    RestOfLine ;
  //=====================================================================
  private boolean DeSpracheKopf()
    {
      if (saved(DeSpracheKopf)) return reuse();
      if (!KOPF2()) return reject();
      if (!Lemma()) return reject();
      if (!next('(')) return reject();
      if (!DeSpracheTemplate()) return reject();
      if (!next(')')) return reject();
      Space();
      if (!KOPF2()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  DeSpracheTemplate = LT "Sprache" SEP "Deutsch" RT ;
  //=====================================================================
  private boolean DeSpracheTemplate()
    {
      if (saved(DeSpracheTemplate)) return reuse();
      if (!LT()) return reject();
      if (!next("Sprache")) return reject();
      if (!SEP()) return reject();
      if (!next("Deutsch")) return reject();
      if (!RT()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Lemma = Letter+ Space {Lemma} ;
  //=====================================================================
  private boolean Lemma()
    {
      if (saved(Lemma)) return reuse();
      if (!Letter()) return reject();
      while (Letter());
      Space();
      sem.Lemma();
      return accept();
    }
  
  //=====================================================================
  //  DeWortart = (WortartKopf WortartBody / UnknownWortartKopf Line*) ;
  //=====================================================================
  private boolean DeWortart()
    {
      if (saved(DeWortart)) return reuse();
      if (!DeWortart_0()
       && !DeWortart_1()
         ) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  DeWortart_0 = WortartKopf WortartBody
  //-------------------------------------------------------------------
  private boolean DeWortart_0()
    {
      if (savedInner(DeWortart_0)) return reuseInner();
      if (!WortartKopf()) return rejectInner();
      WortartBody();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DeWortart_1 = UnknownWortartKopf Line*
  //-------------------------------------------------------------------
  private boolean DeWortart_1()
    {
      if (savedInner(DeWortart_1)) return reuseInner();
      if (!UnknownWortartKopf()) return rejectInner();
      while (Line());
      return acceptInner();
    }
  
  //=====================================================================
  //  WortartKopf = SubstantivKopf {saveEintrag} ;
  //=====================================================================
  private boolean WortartKopf()
    {
      if (saved(WortartKopf)) return reuse();
      if (!SubstantivKopf()) return reject();
      sem.saveEintrag();
      return accept();
    }
  
  //=====================================================================
  //  WortartBody = MiddleSection TranslationsSection?
  //    ~{WortartBody_fail} ;
  //=====================================================================
  private boolean WortartBody()
    {
      if (saved(WortartBody)) return reuse();
      if (WortartBody_0()) return accept();
      else sem.WortartBody_fail();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  WortartBody_0 = MiddleSection TranslationsSection?
  //-------------------------------------------------------------------
  private boolean WortartBody_0()
    {
      if (savedInner(WortartBody_0)) return reuseInner();
      MiddleSection();
      TranslationsSection();
      return acceptInner();
    }
  
  //=====================================================================
  //  UnknownWortartKopf = KOPF3 WortartTemplate _*+ KOPF3 RestOfLine ;
  //=====================================================================
  private boolean UnknownWortartKopf()
    {
      if (saved(UnknownWortartKopf)) return reuse();
      if (!KOPF3()) return reject();
      if (!WortartTemplate()) return reject();
      while (!KOPF3())
        if (!next()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  WortartTemplate = LT "Wortart" SEP TemplateAttr SEP "Deutsch" RT
  //    {WortartTemplate} ;
  //=====================================================================
  private boolean WortartTemplate()
    {
      if (saved(WortartTemplate)) return reuse();
      if (!LT()) return reject();
      if (!next("Wortart")) return reject();
      if (!SEP()) return reject();
      TemplateAttr();
      if (!SEP()) return reject();
      if (!next("Deutsch")) return reject();
      if (!RT()) return reject();
      sem.WortartTemplate();
      return accept();
    }
  
  //=====================================================================
  //  SubstantivKopf = KOPF3 SubstantivTemplate SubstantivAttributes
  //    KOPF3 RestOfLine ;
  //=====================================================================
  private boolean SubstantivKopf()
    {
      if (saved(SubstantivKopf)) return reuse();
      if (!KOPF3()) return reject();
      if (!SubstantivTemplate()) return reject();
      if (!SubstantivAttributes()) return reject();
      if (!KOPF3()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  SubstantivTemplate = LT "Wortart" SEP "Substantiv" SEP "Deutsch" RT
  //    {createSubstantiv} ;
  //=====================================================================
  private boolean SubstantivTemplate()
    {
      if (saved(SubstantivTemplate)) return reuse();
      if (!LT()) return reject();
      if (!next("Wortart")) return reject();
      if (!SEP()) return reject();
      if (!next("Substantiv")) return reject();
      if (!SEP()) return reject();
      if (!next("Deutsch")) return reject();
      if (!RT()) return reject();
      sem.createSubstantiv();
      return accept();
    }
  
  //=====================================================================
  //  SubstantivAttributes = (","? Space SubstantivAttribute)+
  //    ~{SubstantivAttributes_0_fail} / _++ KOPF3 ;
  //=====================================================================
  private boolean SubstantivAttributes()
    {
      if (saved(SubstantivAttributes)) return reuse();
      if (SubstantivAttributes_0()) return accept();
      else sem.SubstantivAttributes_0_fail();
      if (SubstantivAttributes_1()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  SubstantivAttributes_0 = (","? Space SubstantivAttribute)+
  //-------------------------------------------------------------------
  private boolean SubstantivAttributes_0()
    {
      if (savedInner(SubstantivAttributes_0)) return reuseInner();
      if (!SubstantivAttributes_2()) return rejectInner();
      while (SubstantivAttributes_2());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  SubstantivAttributes_1 = _++ KOPF3
  //-------------------------------------------------------------------
  private boolean SubstantivAttributes_1()
    {
      if (savedInner(SubstantivAttributes_1)) return reuseInner();
      if (KOPF3()) return rejectInner();
      do if (!next()) return rejectInner();
        while (!KOPF3());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  SubstantivAttributes_2 = ","? Space SubstantivAttribute
  //-------------------------------------------------------------------
  private boolean SubstantivAttributes_2()
    {
      if (savedInner(SubstantivAttributes_2)) return reuseInner();
      next(',');
      Space();
      if (!SubstantivAttribute()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  SubstantivAttribute = Gender {substantivGender} / WortartTemplate
  //    {substantivWortart} / "''adjektivische Deklination" ","? "''"
  //    {substantivAdjDeklination} ;
  //=====================================================================
  private boolean SubstantivAttribute()
    {
      if (saved(SubstantivAttribute)) return reuse();
      if (Gender())
      { sem.substantivGender(); return accept(); }
      if (WortartTemplate())
      { sem.substantivWortart(); return accept(); }
      if (SubstantivAttribute_0())
      { sem.substantivAdjDeklination(); return accept(); }
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  SubstantivAttribute_0 = "''adjektivische Deklination" ","? "''"
  //-------------------------------------------------------------------
  private boolean SubstantivAttribute_0()
    {
      if (savedInner(SubstantivAttribute_0)) return reuseInner();
      if (!next("''adjektivische Deklination")) return rejectInner();
      next(',');
      if (!next("''")) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  FlexionTable = FlexionTableKopf FlexionForm+ RT RestOfLine ;
  //=====================================================================
  private boolean FlexionTable()
    {
      if (saved(FlexionTable)) return reuse();
      if (!FlexionTableKopf()) return reject();
      if (!FlexionForm()) return reject();
      while (FlexionForm());
      if (!RT()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  FlexionTableKopf = LT "Deutsch Substantiv Übersicht" Space
  //    RestOfLine ;
  //=====================================================================
  private boolean FlexionTableKopf()
    {
      if (saved(FlexionTableKopf)) return reuse();
      if (!LT()) return reject();
      if (!next("Deutsch Substantiv \u00dcbersicht")) return reject();
      Space();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  FlexionForm = SEP (NomSg / NomPl / GenSg / GenPl / DatSg / DatPl /
  //    AkkSg / AkkPl / BadLine) ;
  //=====================================================================
  private boolean FlexionForm()
    {
      if (saved(FlexionForm)) return reuse();
      if (!SEP()) return reject();
      if (!NomSg()
       && !NomPl()
       && !GenSg()
       && !GenPl()
       && !DatSg()
       && !DatPl()
       && !AkkSg()
       && !AkkPl()
       && !BadLine()
         ) return reject();
      return accept();
    }
  
  //=====================================================================
  //  NomSg = "Nominativ Singular" Space OptDigit Space "="
  //    FlexionVariantList RestOfLine {addNomSg} ;
  //=====================================================================
  private boolean NomSg()
    {
      if (saved(NomSg)) return reuse();
      if (!next("Nominativ Singular")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addNomSg();
      return accept();
    }
  
  //=====================================================================
  //  NomPl = "Nominativ Plural" Space OptDigit Space "="
  //    FlexionVariantList RestOfLine {addNomPl} ;
  //=====================================================================
  private boolean NomPl()
    {
      if (saved(NomPl)) return reuse();
      if (!next("Nominativ Plural")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addNomPl();
      return accept();
    }
  
  //=====================================================================
  //  GenSg = "Genitiv Singular" Space OptDigit Space "="
  //    FlexionVariantList RestOfLine {addGenSg} ;
  //=====================================================================
  private boolean GenSg()
    {
      if (saved(GenSg)) return reuse();
      if (!next("Genitiv Singular")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addGenSg();
      return accept();
    }
  
  //=====================================================================
  //  GenPl = "Genitiv Plural" Space OptDigit Space "="
  //    FlexionVariantList RestOfLine {addGenPl} ;
  //=====================================================================
  private boolean GenPl()
    {
      if (saved(GenPl)) return reuse();
      if (!next("Genitiv Plural")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addGenPl();
      return accept();
    }
  
  //=====================================================================
  //  DatSg = "Dativ Singular" Space OptDigit Space "="
  //    FlexionVariantList RestOfLine {addDatSg} ;
  //=====================================================================
  private boolean DatSg()
    {
      if (saved(DatSg)) return reuse();
      if (!next("Dativ Singular")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addDatSg();
      return accept();
    }
  
  //=====================================================================
  //  DatPl = "Dativ Plural" Space OptDigit Space "=" FlexionVariantList
  //    RestOfLine {addDatPl} ;
  //=====================================================================
  private boolean DatPl()
    {
      if (saved(DatPl)) return reuse();
      if (!next("Dativ Plural")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addDatPl();
      return accept();
    }
  
  //=====================================================================
  //  AkkSg = "Akkusativ Singular" Space OptDigit Space "="
  //    FlexionVariantList RestOfLine {addAkkSg} ;
  //=====================================================================
  private boolean AkkSg()
    {
      if (saved(AkkSg)) return reuse();
      if (!next("Akkusativ Singular")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addAkkSg();
      return accept();
    }
  
  //=====================================================================
  //  AkkPl = "Akkusativ Plural" Space OptDigit Space "="
  //    FlexionVariantList RestOfLine {addAkkPl} ;
  //=====================================================================
  private boolean AkkPl()
    {
      if (saved(AkkPl)) return reuse();
      if (!next("Akkusativ Plural")) return reject();
      Space();
      OptDigit();
      Space();
      if (!next('=')) return reject();
      FlexionVariantList();
      if (!RestOfLine()) return reject();
      sem.addAkkPl();
      return accept();
    }
  
  //=====================================================================
  //  FlexionVariantList = Space Phrase (BR Phrase)*
  //    {FlexionVariantList_0} / Space "\u2014" Space
  //    {FlexionVariantList_1} / (!EOL _)* ;
  //=====================================================================
  private boolean FlexionVariantList()
    {
      if (saved(FlexionVariantList)) return reuse();
      if (FlexionVariantList_0())
      { sem.FlexionVariantList_0(); return accept(); }
      if (FlexionVariantList_1())
      { sem.FlexionVariantList_1(); return accept(); }
      if (FlexionVariantList_2()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  FlexionVariantList_0 = Space Phrase (BR Phrase)*
  //-------------------------------------------------------------------
  private boolean FlexionVariantList_0()
    {
      if (savedInner(FlexionVariantList_0)) return reuseInner();
      Space();
      if (!Phrase()) return rejectInner();
      while (FlexionVariantList_3());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  FlexionVariantList_1 = Space "\u2014" Space
  //-------------------------------------------------------------------
  private boolean FlexionVariantList_1()
    {
      if (savedInner(FlexionVariantList_1)) return reuseInner();
      Space();
      if (!next('\u2014')) return rejectInner();
      Space();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  FlexionVariantList_2 = (!EOL _)*
  //-------------------------------------------------------------------
  private boolean FlexionVariantList_2()
    {
      if (savedInner(FlexionVariantList_2)) return reuseInner();
      while (FlexionVariantList_4());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  FlexionVariantList_3 = BR Phrase
  //-------------------------------------------------------------------
  private boolean FlexionVariantList_3()
    {
      if (savedInner(FlexionVariantList_3)) return reuseInner();
      if (!BR()) return rejectInner();
      if (!Phrase()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  FlexionVariantList_4 = !EOL _
  //-------------------------------------------------------------------
  private boolean FlexionVariantList_4()
    {
      if (savedInner(FlexionVariantList_4)) return reuseInner();
      if (!FlexionVariantList_5()) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  FlexionVariantList_5 = !EOL
  //-------------------------------------------------------------------
  private boolean FlexionVariantList_5()
    {
      if (savedInner(FlexionVariantList_5)) return reusePred();
      if (EOL()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  Gender = LT GenderTemplateArgument RT Space {Gender} ;
  //=====================================================================
  private boolean Gender()
    {
      if (saved(Gender)) return reuse();
      if (!LT()) return reject();
      if (!GenderTemplateArgument()) return reject();
      if (!RT()) return reject();
      Space();
      sem.Gender();
      return accept();
    }
  
  //=====================================================================
  //  GenderTemplateArgument = "mf" / "f" ("m" / "n") / "n" ("m" / "f") /
  //    "m" / "f" / "n" / "u" ;
  //=====================================================================
  private boolean GenderTemplateArgument()
    {
      if (saved(GenderTemplateArgument)) return reuse();
      if (next("mf")) return accept();
      if (GenderTemplateArgument_0()) return accept();
      if (GenderTemplateArgument_1()) return accept();
      if (next('m')) return accept();
      if (next('f')) return accept();
      if (next('n')) return accept();
      if (next('u')) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  GenderTemplateArgument_0 = "f" ("m" / "n")
  //-------------------------------------------------------------------
  private boolean GenderTemplateArgument_0()
    {
      if (savedInner(GenderTemplateArgument_0)) return reuseInner();
      if (!next('f')) return rejectInner();
      if (!next('m')
       && !next('n')
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  GenderTemplateArgument_1 = "n" ("m" / "f")
  //-------------------------------------------------------------------
  private boolean GenderTemplateArgument_1()
    {
      if (savedInner(GenderTemplateArgument_1)) return reuseInner();
      if (!next('n')) return rejectInner();
      if (!next('m')
       && !next('f')
         ) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  MiddleSection = (!TranslationsKopf (FlexionTable / Line))* ;
  //=====================================================================
  private boolean MiddleSection()
    {
      if (saved(MiddleSection)) return reuse();
      while (MiddleSection_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  MiddleSection_0 = !TranslationsKopf (FlexionTable / Line)
  //-------------------------------------------------------------------
  private boolean MiddleSection_0()
    {
      if (savedInner(MiddleSection_0)) return reuseInner();
      if (!MiddleSection_1()) return rejectInner();
      if (!FlexionTable()
       && !Line()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  MiddleSection_1 = !TranslationsKopf
  //-------------------------------------------------------------------
  private boolean MiddleSection_1()
    {
      if (savedInner(MiddleSection_1)) return reusePred();
      if (TranslationsKopf()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  MeaningsTextbaustein = MeaningsKopf MeaningList
  //    {MeaningsTextbaustein} ;
  //=====================================================================
  private boolean MeaningsTextbaustein()
    {
      if (saved(MeaningsTextbaustein)) return reuse();
      if (!MeaningsKopf()) return reject();
      MeaningList();
      sem.MeaningsTextbaustein();
      return accept();
    }
  
  //=====================================================================
  //  MeaningsKopf = LT "Bedeutungen" RT RestOfLine ;
  //=====================================================================
  private boolean MeaningsKopf()
    {
      if (saved(MeaningsKopf)) return reuse();
      if (!LT()) return reject();
      if (!next("Bedeutungen")) return reject();
      if (!RT()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  MeaningList = (!TextbausteinEnd (Meaning / Line))* ;
  //=====================================================================
  private boolean MeaningList()
    {
      if (saved(MeaningList)) return reuse();
      while (MeaningList_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  MeaningList_0 = !TextbausteinEnd (Meaning / Line)
  //-------------------------------------------------------------------
  private boolean MeaningList_0()
    {
      if (savedInner(MeaningList_0)) return reuseInner();
      if (!MeaningList_1()) return rejectInner();
      if (!Meaning()
       && !Line()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  MeaningList_1 = !TextbausteinEnd
  //-------------------------------------------------------------------
  private boolean MeaningList_1()
    {
      if (savedInner(MeaningList_1)) return reusePred();
      if (TextbausteinEnd()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  Meaning = ItemNo Template RichLine {Meaning} ;
  //=====================================================================
  private boolean Meaning()
    {
      if (saved(Meaning)) return reuse();
      if (!ItemNo()) return reject();
      if (!Template()) return reject();
      if (!RichLine()) return reject();
      sem.Meaning();
      return accept();
    }
  
  //=====================================================================
  //  TranslationsSection = TranslationsKopf (!TranslationsTableKopf
  //    Line)* TranslationsTable (!KopfStart Line)* ;
  //=====================================================================
  private boolean TranslationsSection()
    {
      if (saved(TranslationsSection)) return reuse();
      if (!TranslationsKopf()) return reject();
      while (TranslationsSection_0());
      if (!TranslationsTable()) return reject();
      while (TranslationsSection_1());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsSection_0 = !TranslationsTableKopf Line
  //-------------------------------------------------------------------
  private boolean TranslationsSection_0()
    {
      if (savedInner(TranslationsSection_0)) return reuseInner();
      if (!TranslationsSection_2()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsSection_1 = !KopfStart Line
  //-------------------------------------------------------------------
  private boolean TranslationsSection_1()
    {
      if (savedInner(TranslationsSection_1)) return reuseInner();
      if (!TranslationsSection_3()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsSection_2 = !TranslationsTableKopf
  //-------------------------------------------------------------------
  private boolean TranslationsSection_2()
    {
      if (savedInner(TranslationsSection_2)) return reusePred();
      if (TranslationsTableKopf()) return rejectNot();
      return acceptNot();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsSection_3 = !KopfStart
  //-------------------------------------------------------------------
  private boolean TranslationsSection_3()
    {
      if (savedInner(TranslationsSection_3)) return reusePred();
      if (KopfStart()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  TranslationsKopf = KOPF4 "Übersetzungen" Space KOPF4 RestOfLine ;
  //=====================================================================
  private boolean TranslationsKopf()
    {
      if (saved(TranslationsKopf)) return reuse();
      if (!KOPF4()) return reject();
      if (!next("\u00dcbersetzungen")) return reject();
      Space();
      if (!KOPF4()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  TranslationsTable = TranslationsTableKopf (LangTranslations /
  //    DialectTable / !RT Line)*+ RT RestOfLine ;
  //=====================================================================
  private boolean TranslationsTable()
    {
      if (saved(TranslationsTable)) return reuse();
      if (!TranslationsTableKopf()) return reject();
      while (!RT())
        if (!TranslationsTable_0()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsTable_0 = LangTranslations / DialectTable / !RT Line
  //-------------------------------------------------------------------
  private boolean TranslationsTable_0()
    {
      if (savedInner(TranslationsTable_0)) return reuseInner();
      if (LangTranslations()) return acceptInner();
      if (DialectTable()) return acceptInner();
      if (TranslationsTable_1()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsTable_1 = !RT Line
  //-------------------------------------------------------------------
  private boolean TranslationsTable_1()
    {
      if (savedInner(TranslationsTable_1)) return reuseInner();
      if (!TranslationsTable_2()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsTable_2 = !RT
  //-------------------------------------------------------------------
  private boolean TranslationsTable_2()
    {
      if (savedInner(TranslationsTable_2)) return reusePred();
      if (RT()) return rejectNot();
      return acceptNot();
    }
  
  //=====================================================================
  //  TranslationsTableKopf = LT "Ü-Tabelle" Line ;
  //=====================================================================
  private boolean TranslationsTableKopf()
    {
      if (saved(TranslationsTableKopf)) return reuse();
      if (!LT()) return reject();
      if (!next("\u00dc-Tabelle")) return reject();
      if (!Line()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  LangTranslations = LangLvl Lang ":" Space TranslationMeaning*
  //    RestOfLine {addTranslationsForLanguage} ;
  //=====================================================================
  private boolean LangTranslations()
    {
      if (saved(LangTranslations)) return reuse();
      if (!LangLvl()) return reject();
      if (!Lang()) return reject();
      if (!next(':')) return reject();
      Space();
      while (TranslationMeaning());
      if (!RestOfLine()) return reject();
      sem.addTranslationsForLanguage();
      return accept();
    }
  
  //=====================================================================
  //  LangLvl = "*"+ ;
  //=====================================================================
  private boolean LangLvl()
    {
      if (saved(LangLvl)) return reuse();
      if (!next('*')) return reject();
      while (next('*'));
      return accept();
    }
  
  //=====================================================================
  //  Lang = LT Word RT {Lang} ;
  //=====================================================================
  private boolean Lang()
    {
      if (saved(Lang)) return reuse();
      if (!LT()) return reject();
      if (!Word()) return reject();
      if (!RT()) return reject();
      sem.Lang();
      return accept();
    }
  
  //=====================================================================
  //  TranslationMeaning = ItemNo Translation+ {TranslationMeaning} ;
  //=====================================================================
  private boolean TranslationMeaning()
    {
      if (saved(TranslationMeaning)) return reuse();
      if (!ItemNo()) return reject();
      if (!Translation()) return reject();
      while (Translation());
      sem.TranslationMeaning();
      return accept();
    }
  
  //=====================================================================
  //  Translation = TranslationDetails (UeTemplate / UetTemplate) Gender?
  //    TranslationDetails (COMMA / SEMICOLON)? Space {Translation} ;
  //=====================================================================
  private boolean Translation()
    {
      if (saved(Translation)) return reuse();
      TranslationDetails();
      if (!UeTemplate()
       && !UetTemplate()
         ) return reject();
      Gender();
      TranslationDetails();
      Translation_0();
      Space();
      sem.Translation();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Translation_0 = COMMA / SEMICOLON
  //-------------------------------------------------------------------
  private boolean Translation_0()
    {
      if (savedInner(Translation_0)) return reuseInner();
      if (COMMA()) return acceptInner();
      if (SEMICOLON()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  TranslationDetails = (CursiveText / Link / !(ItemNo / UeTemplate /
  //    UetTemplate / COMMA / SEMICOLON / EOL) _)* (COMMA / SEMICOLON)?
  //    ;
  //=====================================================================
  private boolean TranslationDetails()
    {
      if (saved(TranslationDetails)) return reuse();
      while (TranslationDetails_0());
      Translation_0();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TranslationDetails_0 = CursiveText / Link / !(ItemNo / UeTemplate
  //    / UetTemplate / COMMA / SEMICOLON / EOL) _
  //-------------------------------------------------------------------
  private boolean TranslationDetails_0()
    {
      if (savedInner(TranslationDetails_0)) return reuseInner();
      if (CursiveText()) return acceptInner();
      if (Link()) return acceptInner();
      if (TranslationDetails_1()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationDetails_1 = !(ItemNo / UeTemplate / UetTemplate /
  //    COMMA / SEMICOLON / EOL) _
  //-------------------------------------------------------------------
  private boolean TranslationDetails_1()
    {
      if (savedInner(TranslationDetails_1)) return reuseInner();
      if (!TranslationDetails_2()) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationDetails_2 = !(ItemNo / UeTemplate / UetTemplate /
  //    COMMA / SEMICOLON / EOL)
  //-------------------------------------------------------------------
  private boolean TranslationDetails_2()
    {
      if (savedInner(TranslationDetails_2)) return reusePred();
      if (TranslationDetails_3()) return rejectNot();
      return acceptNot();
    }
  
  //-------------------------------------------------------------------
  //  TranslationDetails_3 = ItemNo / UeTemplate / UetTemplate / COMMA
  //    / SEMICOLON / EOL
  //-------------------------------------------------------------------
  private boolean TranslationDetails_3()
    {
      if (savedInner(TranslationDetails_3)) return reuseInner();
      if (ItemNo()) return acceptInner();
      if (UeTemplate()) return acceptInner();
      if (UetTemplate()) return acceptInner();
      if (COMMA()) return acceptInner();
      if (SEMICOLON()) return acceptInner();
      if (EOL()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  UeTemplate = LT ("Ü" / "Ü?") SEP TemplateAttr SEP TemplateAttr (SEP
  //    TemplateAttr)? (SEP TemplateAttr)? RT Space {UeTemplate} ;
  //=====================================================================
  private boolean UeTemplate()
    {
      if (saved(UeTemplate)) return reuse();
      if (!LT()) return reject();
      if (!next('\u00dc')
       && !next("\u00dc?")
         ) return reject();
      if (!SEP()) return reject();
      TemplateAttr();
      if (!SEP()) return reject();
      TemplateAttr();
      UeTemplate_0();
      UeTemplate_0();
      if (!RT()) return reject();
      Space();
      sem.UeTemplate();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  UeTemplate_0 = SEP TemplateAttr
  //-------------------------------------------------------------------
  private boolean UeTemplate_0()
    {
      if (savedInner(UeTemplate_0)) return reuseInner();
      if (!SEP()) return rejectInner();
      TemplateAttr();
      return acceptInner();
    }
  
  //=====================================================================
  //  UetTemplate = LT ("Üt" / "Üt?") SEP TemplateAttr SEP TemplateAttr
  //    SEP TemplateAttr (SEP TemplateAttr)? (SEP TemplateAttr)? RT Space
  //    {UetTemplate} ;
  //=====================================================================
  private boolean UetTemplate()
    {
      if (saved(UetTemplate)) return reuse();
      if (!LT()) return reject();
      if (!next("\u00dct")
       && !next("\u00dct?")
         ) return reject();
      if (!SEP()) return reject();
      TemplateAttr();
      if (!SEP()) return reject();
      TemplateAttr();
      if (!SEP()) return reject();
      TemplateAttr();
      UeTemplate_0();
      UeTemplate_0();
      if (!RT()) return reject();
      Space();
      sem.UetTemplate();
      return accept();
    }
  
  //=====================================================================
  //  DialectTable = "|Dialekttabelle=" RestOfLine (!RT Line)* ;
  //=====================================================================
  private boolean DialectTable()
    {
      if (saved(DialectTable)) return reuse();
      if (!next("|Dialekttabelle=")) return reject();
      if (!RestOfLine()) return reject();
      while (TranslationsTable_1());
      return accept();
    }
  
  //=====================================================================
  //  KOPF2 = "==" Space ;
  //=====================================================================
  private boolean KOPF2()
    {
      if (saved(KOPF2)) return reuse();
      if (!next("==")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  KOPF3 = "===" Space ;
  //=====================================================================
  private boolean KOPF3()
    {
      if (saved(KOPF3)) return reuse();
      if (!next("===")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  KOPF4 = "====" Space ;
  //=====================================================================
  private boolean KOPF4()
    {
      if (saved(KOPF4)) return reuse();
      if (!next("====")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  KopfStart = "==" ;
  //=====================================================================
  private boolean KopfStart()
    {
      if (saved(KopfStart)) return reuse();
      if (!next("==")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  SEP = "|" Space ;
  //=====================================================================
  private boolean SEP()
    {
      if (saved(SEP)) return reuse();
      if (!next('|')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  TextbausteinEnd = LT / KopfStart / EOF ;
  //=====================================================================
  private boolean TextbausteinEnd()
    {
      if (saved(TextbausteinEnd)) return reuse();
      if (LT()) return accept();
      if (KopfStart()) return accept();
      if (EOF()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  LT = "{{" Space ;
  //=====================================================================
  private boolean LT()
    {
      if (saved(LT)) return reuse();
      if (!next("{{")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  RT = "}}" Space ;
  //=====================================================================
  private boolean RT()
    {
      if (saved(RT)) return reuse();
      if (!next("}}")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Template = LT TemplateAttr (SEP TemplateAttr)* RT {Template} ;
  //=====================================================================
  private boolean Template()
    {
      if (saved(Template)) return reuse();
      if (!LT()) return reject();
      TemplateAttr();
      while (UeTemplate_0());
      if (!RT()) return reject();
      sem.Template();
      return accept();
    }
  
  //=====================================================================
  //  TemplateAttr = Link+ {TemplateAttr_0} / Link*
  //    (TemplateAttrPlainText Link*)+ {TemplateAttr_1} / Space
  //    {TemplateAttr_2} ;
  //=====================================================================
  private boolean TemplateAttr()
    {
      if (saved(TemplateAttr)) return reuse();
      if (TemplateAttr_0())
      { sem.TemplateAttr_0(); return accept(); }
      if (TemplateAttr_1())
      { sem.TemplateAttr_1(); return accept(); }
      if (Space())
      { sem.TemplateAttr_2(); return accept(); }
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  TemplateAttr_0 = Link+
  //-------------------------------------------------------------------
  private boolean TemplateAttr_0()
    {
      if (savedInner(TemplateAttr_0)) return reuseInner();
      if (!Link()) return rejectInner();
      while (Link());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TemplateAttr_1 = Link* (TemplateAttrPlainText Link*)+
  //-------------------------------------------------------------------
  private boolean TemplateAttr_1()
    {
      if (savedInner(TemplateAttr_1)) return reuseInner();
      while (Link());
      if (!TemplateAttr_2()) return rejectInner();
      while (TemplateAttr_2());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TemplateAttr_2 = TemplateAttrPlainText Link*
  //-------------------------------------------------------------------
  private boolean TemplateAttr_2()
    {
      if (savedInner(TemplateAttr_2)) return reuseInner();
      if (!TemplateAttrPlainText()) return rejectInner();
      while (Link());
      return acceptInner();
    }
  
  //=====================================================================
  //  TemplateAttrPlainText = (!(SEP / RT / Link) _)+ ;
  //=====================================================================
  private boolean TemplateAttrPlainText()
    {
      if (saved(TemplateAttrPlainText)) return reuse();
      if (!TemplateAttrPlainText_0()) return reject();
      while (TemplateAttrPlainText_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TemplateAttrPlainText_0 = !(SEP / RT / Link) _
  //-------------------------------------------------------------------
  private boolean TemplateAttrPlainText_0()
    {
      if (savedInner(TemplateAttrPlainText_0)) return reuseInner();
      if (!TemplateAttrPlainText_1()) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TemplateAttrPlainText_1 = !(SEP / RT / Link)
  //-------------------------------------------------------------------
  private boolean TemplateAttrPlainText_1()
    {
      if (savedInner(TemplateAttrPlainText_1)) return reusePred();
      if (TemplateAttrPlainText_2()) return rejectNot();
      return acceptNot();
    }
  
  //-------------------------------------------------------------------
  //  TemplateAttrPlainText_2 = SEP / RT / Link
  //-------------------------------------------------------------------
  private boolean TemplateAttrPlainText_2()
    {
      if (savedInner(TemplateAttrPlainText_2)) return reuseInner();
      if (SEP()) return acceptInner();
      if (RT()) return acceptInner();
      if (Link()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  LL = "[[" ;
  //=====================================================================
  private boolean LL()
    {
      if (saved(LL)) return reuse();
      if (!next("[[")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  RL = "]]" ;
  //=====================================================================
  private boolean RL()
    {
      if (saved(RL)) return reuse();
      if (!next("]]")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Link = LL LinkAttr (SEP LinkAttr)? RL {Link} ;
  //=====================================================================
  private boolean Link()
    {
      if (saved(Link)) return reuse();
      if (!LL()) return reject();
      if (!LinkAttr()) return reject();
      Link_0();
      if (!RL()) return reject();
      sem.Link();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Link_0 = SEP LinkAttr
  //-------------------------------------------------------------------
  private boolean Link_0()
    {
      if (savedInner(Link_0)) return reuseInner();
      if (!SEP()) return rejectInner();
      if (!LinkAttr()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  LinkAttr = (!(SEP / RL) _)+ ;
  //=====================================================================
  private boolean LinkAttr()
    {
      if (saved(LinkAttr)) return reuse();
      if (!LinkAttr_0()) return reject();
      while (LinkAttr_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  LinkAttr_0 = !(SEP / RL) _
  //-------------------------------------------------------------------
  private boolean LinkAttr_0()
    {
      if (savedInner(LinkAttr_0)) return reuseInner();
      if (!LinkAttr_1()) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  LinkAttr_1 = !(SEP / RL)
  //-------------------------------------------------------------------
  private boolean LinkAttr_1()
    {
      if (savedInner(LinkAttr_1)) return reusePred();
      if (LinkAttr_2()) return rejectNot();
      return acceptNot();
    }
  
  //-------------------------------------------------------------------
  //  LinkAttr_2 = SEP / RL
  //-------------------------------------------------------------------
  private boolean LinkAttr_2()
    {
      if (savedInner(LinkAttr_2)) return reuseInner();
      if (SEP()) return acceptInner();
      if (RL()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  RichLine = Link+ EOL {RichLine_0} / (Link? PlainText Link?)+ EOL
  //    {RichLine_1} / Space EOL {RichLine_2} ;
  //=====================================================================
  private boolean RichLine()
    {
      if (saved(RichLine)) return reuse();
      if (RichLine_0())
      { sem.RichLine_0(); return accept(); }
      if (RichLine_1())
      { sem.RichLine_1(); return accept(); }
      if (RichLine_2())
      { sem.RichLine_2(); return accept(); }
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  RichLine_0 = Link+ EOL
  //-------------------------------------------------------------------
  private boolean RichLine_0()
    {
      if (savedInner(RichLine_0)) return reuseInner();
      if (!Link()) return rejectInner();
      while (Link());
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  RichLine_1 = (Link? PlainText Link?)+ EOL
  //-------------------------------------------------------------------
  private boolean RichLine_1()
    {
      if (savedInner(RichLine_1)) return reuseInner();
      if (!RichLine_3()) return rejectInner();
      while (RichLine_3());
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  RichLine_2 = Space EOL
  //-------------------------------------------------------------------
  private boolean RichLine_2()
    {
      if (savedInner(RichLine_2)) return reuseInner();
      Space();
      if (!EOL()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  RichLine_3 = Link? PlainText Link?
  //-------------------------------------------------------------------
  private boolean RichLine_3()
    {
      if (savedInner(RichLine_3)) return reuseInner();
      Link();
      if (!PlainText()) return rejectInner();
      Link();
      return acceptInner();
    }
  
  //=====================================================================
  //  PlainText = (!EOL _)+ ;
  //=====================================================================
  private boolean PlainText()
    {
      if (saved(PlainText)) return reuse();
      if (!FlexionVariantList_4()) return reject();
      while (FlexionVariantList_4());
      return accept();
    }
  
  //=====================================================================
  //  CursiveText = "''" _*+ "''" Space ;
  //=====================================================================
  private boolean CursiveText()
    {
      if (saved(CursiveText)) return reuse();
      if (!next("''")) return reject();
      while (!next("''"))
        if (!next()) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  ItemNo = "[" _++ "]" Space {ItemNo} ;
  //=====================================================================
  private boolean ItemNo()
    {
      if (saved(ItemNo)) return reuse();
      if (!next('[')) return reject();
      if (next(']')) return reject();
      do if (!next()) return reject();
        while (!next(']'));
      Space();
      sem.ItemNo();
      return accept();
    }
  
  //=====================================================================
  //  BR = "<br" Space "/>" ;
  //=====================================================================
  private boolean BR()
    {
      if (saved(BR)) return reuse();
      if (!next("<br")) return reject();
      Space();
      if (!next("/>")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Comment = CommentStart _++ CommentEnd Space ;
  //=====================================================================
  private boolean Comment()
    {
      if (saved(Comment)) return reuse();
      if (!CommentStart()) return reject();
      if (CommentEnd()) return reject();
      do if (!next()) return reject();
        while (!CommentEnd());
      Space();
      return accept();
    }
  
  //=====================================================================
  //  CommentStart = "<!--" Space ;
  //=====================================================================
  private boolean CommentStart()
    {
      if (saved(CommentStart)) return reuse();
      if (!next("<!--")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  CommentEnd = "-->" Space ;
  //=====================================================================
  private boolean CommentEnd()
    {
      if (saved(CommentEnd)) return reuse();
      if (!next("-->")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Line = _++ EOL ;
  //=====================================================================
  private boolean Line()
    {
      if (saved(Line)) return reuse();
      if (EOL()) return reject();
      do if (!next()) return reject();
        while (!EOL());
      return accept();
    }
  
  //=====================================================================
  //  BadLine = _++ EOL ;
  //=====================================================================
  private boolean BadLine()
    {
      if (saved(BadLine)) return reuse();
      if (EOL()) return reject();
      do if (!next()) return reject();
        while (!EOL());
      return accept();
    }
  
  //=====================================================================
  //  EmptyLine = Space EOL ;
  //=====================================================================
  private boolean EmptyLine()
    {
      if (saved(EmptyLine)) return reuse();
      Space();
      if (!EOL()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  RestOfLine = _*+ EOL ;
  //=====================================================================
  private boolean RestOfLine()
    {
      if (saved(RestOfLine)) return reuse();
      while (!EOL())
        if (!next()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Digit = [0-9] ;
  //=====================================================================
  private boolean Digit()
    {
      if (saved(Digit)) return reuse();
      if (!nextIn('0','9')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  OptDigit = Digit? ;
  //=====================================================================
  private boolean OptDigit()
    {
      if (saved(OptDigit)) return reuse();
      Digit();
      return accept();
    }
  
  //=====================================================================
  //  Number = Digit+ ;
  //=====================================================================
  private boolean Number()
    {
      if (saved(Number)) return reuse();
      if (!Digit()) return reject();
      while (Digit());
      return accept();
    }
  
  //=====================================================================
  //  Letter = [a-z] / [A-Z] / [äÄüÜöÖß] ;
  //=====================================================================
  private boolean Letter()
    {
      if (saved(Letter)) return reuse();
      if (nextIn('a','z')) return accept();
      if (nextIn('A','Z')) return accept();
      if (nextIn("\u00e4\u00c4\u00fc\u00dc\u00f6\u00d6\u00df")) return accept();
      return reject();
    }
  
  //=====================================================================
  //  Word = Letter (Letter / [-'])* ;
  //=====================================================================
  private boolean Word()
    {
      if (saved(Word)) return reuse();
      if (!Letter()) return reject();
      while (Word_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Word_0 = Letter / [-']
  //-------------------------------------------------------------------
  private boolean Word_0()
    {
      if (savedInner(Word_0)) return reuseInner();
      if (Letter()) return acceptInner();
      if (nextIn("-'")) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  Phrase = Word (Space Word)* ;
  //=====================================================================
  private boolean Phrase()
    {
      if (saved(Phrase)) return reuse();
      if (!Word()) return reject();
      while (Phrase_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Phrase_0 = Space Word
  //-------------------------------------------------------------------
  private boolean Phrase_0()
    {
      if (savedInner(Phrase_0)) return reuseInner();
      Space();
      if (!Word()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Space = " "* ;
  //=====================================================================
  private boolean Space()
    {
      if (saved(Space)) return reuse();
      while (next(' '));
      return accept();
    }
  
  //=====================================================================
  //  COMMA = "," Space ;
  //=====================================================================
  private boolean COMMA()
    {
      if (saved(COMMA)) return reuse();
      if (!next(',')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  SEMICOLON = ";" Space ;
  //=====================================================================
  private boolean SEMICOLON()
    {
      if (saved(SEMICOLON)) return reuse();
      if (!next(';')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  EOF = !_ ;
  //=====================================================================
  private boolean EOF()
    {
      if (saved(EOF)) return reuse();
      if (!aheadNot()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  EOL = [\r\n]+ / EOF ;
  //=====================================================================
  private boolean EOL()
    {
      if (saved(EOL)) return reuse();
      if (EOL_0()) return accept();
      if (EOF()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  EOL_0 = [\r\n]+
  //-------------------------------------------------------------------
  private boolean EOL_0()
    {
      if (savedInner(EOL_0)) return reuseInner();
      if (!nextIn("\r\n")) return rejectInner();
      while (nextIn("\r\n"));
      return acceptInner();
    }
  
  //=======================================================================
  //
  //  Cache objects
  //
  //=======================================================================
  
  final Cache Dokument = new Cache("Dokument","Dokument");
  final Cache Eintrag = new Cache("Eintrag","Eintrag");
  final Cache OtherLangEintrag = new Cache("OtherLangEintrag","OtherLangEintrag");
  final Cache DeEintrag = new Cache("DeEintrag","DeEintrag");
  final Cache DeSpracheKopf = new Cache("DeSpracheKopf","DeSpracheKopf");
  final Cache DeSpracheTemplate = new Cache("DeSpracheTemplate","DeSpracheTemplate");
  final Cache Lemma = new Cache("Lemma","Lemma");
  final Cache DeWortart = new Cache("DeWortart","DeWortart");
  final Cache WortartKopf = new Cache("WortartKopf","WortartKopf");
  final Cache WortartBody = new Cache("WortartBody","WortartBody");
  final Cache UnknownWortartKopf = new Cache("UnknownWortartKopf","UnknownWortartKopf");
  final Cache WortartTemplate = new Cache("WortartTemplate","WortartTemplate");
  final Cache SubstantivKopf = new Cache("SubstantivKopf","SubstantivKopf");
  final Cache SubstantivTemplate = new Cache("SubstantivTemplate","SubstantivTemplate");
  final Cache SubstantivAttributes = new Cache("SubstantivAttributes","SubstantivAttributes");
  final Cache SubstantivAttribute = new Cache("SubstantivAttribute","SubstantivAttribute");
  final Cache FlexionTable = new Cache("FlexionTable","FlexionTable");
  final Cache FlexionTableKopf = new Cache("FlexionTableKopf","FlexionTableKopf");
  final Cache FlexionForm = new Cache("FlexionForm","FlexionForm");
  final Cache NomSg = new Cache("NomSg","NomSg");
  final Cache NomPl = new Cache("NomPl","NomPl");
  final Cache GenSg = new Cache("GenSg","GenSg");
  final Cache GenPl = new Cache("GenPl","GenPl");
  final Cache DatSg = new Cache("DatSg","DatSg");
  final Cache DatPl = new Cache("DatPl","DatPl");
  final Cache AkkSg = new Cache("AkkSg","AkkSg");
  final Cache AkkPl = new Cache("AkkPl","AkkPl");
  final Cache FlexionVariantList = new Cache("FlexionVariantList","FlexionVariantList");
  final Cache Gender = new Cache("Gender","Gender");
  final Cache GenderTemplateArgument = new Cache("GenderTemplateArgument","GenderTemplateArgument");
  final Cache MiddleSection = new Cache("MiddleSection","MiddleSection");
  final Cache MeaningsTextbaustein = new Cache("MeaningsTextbaustein","MeaningsTextbaustein");
  final Cache MeaningsKopf = new Cache("MeaningsKopf","MeaningsKopf");
  final Cache MeaningList = new Cache("MeaningList","MeaningList");
  final Cache Meaning = new Cache("Meaning","Meaning");
  final Cache TranslationsSection = new Cache("TranslationsSection","TranslationsSection");
  final Cache TranslationsKopf = new Cache("TranslationsKopf","TranslationsKopf");
  final Cache TranslationsTable = new Cache("TranslationsTable","TranslationsTable");
  final Cache TranslationsTableKopf = new Cache("TranslationsTableKopf","TranslationsTableKopf");
  final Cache LangTranslations = new Cache("LangTranslations","LangTranslations");
  final Cache LangLvl = new Cache("LangLvl","LangLvl");
  final Cache Lang = new Cache("Lang","Lang");
  final Cache TranslationMeaning = new Cache("TranslationMeaning","TranslationMeaning");
  final Cache Translation = new Cache("Translation","Translation");
  final Cache TranslationDetails = new Cache("TranslationDetails","TranslationDetails");
  final Cache UeTemplate = new Cache("UeTemplate","UeTemplate");
  final Cache UetTemplate = new Cache("UetTemplate","UetTemplate");
  final Cache DialectTable = new Cache("DialectTable","DialectTable");
  final Cache KOPF2 = new Cache("KOPF2","KOPF2");
  final Cache KOPF3 = new Cache("KOPF3","KOPF3");
  final Cache KOPF4 = new Cache("KOPF4","KOPF4");
  final Cache KopfStart = new Cache("KopfStart","KopfStart");
  final Cache SEP = new Cache("SEP","SEP");
  final Cache TextbausteinEnd = new Cache("TextbausteinEnd","TextbausteinEnd");
  final Cache LT = new Cache("LT","LT");
  final Cache RT = new Cache("RT","RT");
  final Cache Template = new Cache("Template","Template");
  final Cache TemplateAttr = new Cache("TemplateAttr","TemplateAttr");
  final Cache TemplateAttrPlainText = new Cache("TemplateAttrPlainText","TemplateAttrPlainText");
  final Cache LL = new Cache("LL","LL");
  final Cache RL = new Cache("RL","RL");
  final Cache Link = new Cache("Link","Link");
  final Cache LinkAttr = new Cache("LinkAttr","LinkAttr");
  final Cache RichLine = new Cache("RichLine","RichLine");
  final Cache PlainText = new Cache("PlainText","PlainText");
  final Cache CursiveText = new Cache("CursiveText","CursiveText");
  final Cache ItemNo = new Cache("ItemNo","ItemNo");
  final Cache BR = new Cache("BR","BR");
  final Cache Comment = new Cache("Comment","Comment");
  final Cache CommentStart = new Cache("CommentStart","CommentStart");
  final Cache CommentEnd = new Cache("CommentEnd","CommentEnd");
  final Cache Line = new Cache("Line","Line");
  final Cache BadLine = new Cache("BadLine","BadLine");
  final Cache EmptyLine = new Cache("EmptyLine","EmptyLine");
  final Cache RestOfLine = new Cache("RestOfLine","RestOfLine");
  final Cache Digit = new Cache("Digit","Digit");
  final Cache OptDigit = new Cache("OptDigit","OptDigit");
  final Cache Number = new Cache("Number","Number");
  final Cache Letter = new Cache("Letter","Letter");
  final Cache Word = new Cache("Word","Word");
  final Cache Phrase = new Cache("Phrase","Phrase");
  final Cache Space = new Cache("Space","Space");
  final Cache COMMA = new Cache("COMMA","COMMA");
  final Cache SEMICOLON = new Cache("SEMICOLON","SEMICOLON");
  final Cache EOF = new Cache("EOF","EOF");
  final Cache EOL = new Cache("EOL","EOL");
  
  final Cache Dokument_0 = new Cache("Dokument_0"); // !KOPF2 Line
  final Cache Dokument_1 = new Cache("Dokument_1","not KOPF2"); // !KOPF2
  final Cache OtherLangEintrag_0 = new Cache("OtherLangEintrag_0"); // !DeSpracheKopf Line
  final Cache OtherLangEintrag_1 = new Cache("OtherLangEintrag_1","not DeSpracheKopf"); // !DeSpracheKopf
  final Cache DeWortart_0 = new Cache("DeWortart_0"); // WortartKopf WortartBody
  final Cache DeWortart_1 = new Cache("DeWortart_1"); // UnknownWortartKopf Line*
  final Cache WortartBody_0 = new Cache("WortartBody_0"); // MiddleSection TranslationsSection?
  final Cache SubstantivAttributes_0 = new Cache("SubstantivAttributes_0"); // (","? Space SubstantivAttribute)+
  final Cache SubstantivAttributes_1 = new Cache("SubstantivAttributes_1"); // _++ KOPF3
  final Cache SubstantivAttributes_2 = new Cache("SubstantivAttributes_2"); // ","? Space SubstantivAttribute
  final Cache SubstantivAttribute_0 = new Cache("SubstantivAttribute_0"); // "''adjektivische Deklination" ","? "''"
  final Cache FlexionVariantList_0 = new Cache("FlexionVariantList_0"); // Space Phrase (BR Phrase)*
  final Cache FlexionVariantList_1 = new Cache("FlexionVariantList_1"); // Space "\u2014" Space
  final Cache FlexionVariantList_2 = new Cache("FlexionVariantList_2"); // (!EOL _)*
  final Cache FlexionVariantList_3 = new Cache("FlexionVariantList_3"); // BR Phrase
  final Cache FlexionVariantList_4 = new Cache("FlexionVariantList_4"); // !EOL _
  final Cache FlexionVariantList_5 = new Cache("FlexionVariantList_5","not EOL"); // !EOL
  final Cache GenderTemplateArgument_0 = new Cache("GenderTemplateArgument_0"); // "f" ("m" / "n")
  final Cache GenderTemplateArgument_1 = new Cache("GenderTemplateArgument_1"); // "n" ("m" / "f")
  final Cache MiddleSection_0 = new Cache("MiddleSection_0"); // !TranslationsKopf (FlexionTable / Line)
  final Cache MiddleSection_1 = new Cache("MiddleSection_1","not TranslationsKopf"); // !TranslationsKopf
  final Cache MeaningList_0 = new Cache("MeaningList_0"); // !TextbausteinEnd (Meaning / Line)
  final Cache MeaningList_1 = new Cache("MeaningList_1","not TextbausteinEnd"); // !TextbausteinEnd
  final Cache TranslationsSection_0 = new Cache("TranslationsSection_0"); // !TranslationsTableKopf Line
  final Cache TranslationsSection_1 = new Cache("TranslationsSection_1"); // !KopfStart Line
  final Cache TranslationsSection_2 = new Cache("TranslationsSection_2","not TranslationsTableKopf"); // !TranslationsTableKopf
  final Cache TranslationsSection_3 = new Cache("TranslationsSection_3","not KopfStart"); // !KopfStart
  final Cache TranslationsTable_0 = new Cache("TranslationsTable_0"); // LangTranslations / DialectTable / !RT Line
  final Cache TranslationsTable_1 = new Cache("TranslationsTable_1"); // !RT Line
  final Cache TranslationsTable_2 = new Cache("TranslationsTable_2","not RT"); // !RT
  final Cache Translation_0 = new Cache("Translation_0"); // COMMA / SEMICOLON
  final Cache TranslationDetails_0 = new Cache("TranslationDetails_0"); // CursiveText / Link / !(ItemNo / UeTemplate / UetTemplate / COMMA / SEMICOLON / EOL) _
  final Cache TranslationDetails_1 = new Cache("TranslationDetails_1"); // !(ItemNo / UeTemplate / UetTemplate / COMMA / SEMICOLON / EOL) _
  final Cache TranslationDetails_2 = new Cache("TranslationDetails_2","not ItemNo / UeTemplate / UetTemplate / COMMA / SEMICOLON / EOL"); // !(ItemNo / UeTemplate / UetTemplate / COMMA / SEMICOLON / EOL)
  final Cache TranslationDetails_3 = new Cache("TranslationDetails_3"); // ItemNo / UeTemplate / UetTemplate / COMMA / SEMICOLON / EOL
  final Cache UeTemplate_0 = new Cache("UeTemplate_0"); // SEP TemplateAttr
  final Cache TemplateAttr_0 = new Cache("TemplateAttr_0"); // Link+
  final Cache TemplateAttr_1 = new Cache("TemplateAttr_1"); // Link* (TemplateAttrPlainText Link*)+
  final Cache TemplateAttr_2 = new Cache("TemplateAttr_2"); // TemplateAttrPlainText Link*
  final Cache TemplateAttrPlainText_0 = new Cache("TemplateAttrPlainText_0"); // !(SEP / RT / Link) _
  final Cache TemplateAttrPlainText_1 = new Cache("TemplateAttrPlainText_1","not SEP / RT / Link"); // !(SEP / RT / Link)
  final Cache TemplateAttrPlainText_2 = new Cache("TemplateAttrPlainText_2"); // SEP / RT / Link
  final Cache Link_0 = new Cache("Link_0"); // SEP LinkAttr
  final Cache LinkAttr_0 = new Cache("LinkAttr_0"); // !(SEP / RL) _
  final Cache LinkAttr_1 = new Cache("LinkAttr_1","not SEP / RL"); // !(SEP / RL)
  final Cache LinkAttr_2 = new Cache("LinkAttr_2"); // SEP / RL
  final Cache RichLine_0 = new Cache("RichLine_0"); // Link+ EOL
  final Cache RichLine_1 = new Cache("RichLine_1"); // (Link? PlainText Link?)+ EOL
  final Cache RichLine_2 = new Cache("RichLine_2"); // Space EOL
  final Cache RichLine_3 = new Cache("RichLine_3"); // Link? PlainText Link?
  final Cache Word_0 = new Cache("Word_0"); // Letter / [-']
  final Cache Phrase_0 = new Cache("Phrase_0"); // Space Word
  final Cache EOL_0 = new Cache("EOL_0"); // [\r\n]+
  
  //-------------------------------------------------------------------
  //  List of Cache objects
  //-------------------------------------------------------------------
  
  Cache[] cacheList =
  {
    Dokument,Eintrag,OtherLangEintrag,DeEintrag,DeSpracheKopf,
    DeSpracheTemplate,Lemma,DeWortart,WortartKopf,WortartBody,
    UnknownWortartKopf,WortartTemplate,SubstantivKopf,
    SubstantivTemplate,SubstantivAttributes,SubstantivAttribute,
    FlexionTable,FlexionTableKopf,FlexionForm,NomSg,NomPl,GenSg,GenPl,
    DatSg,DatPl,AkkSg,AkkPl,FlexionVariantList,Gender,
    GenderTemplateArgument,MiddleSection,MeaningsTextbaustein,
    MeaningsKopf,MeaningList,Meaning,TranslationsSection,
    TranslationsKopf,TranslationsTable,TranslationsTableKopf,
    LangTranslations,LangLvl,Lang,TranslationMeaning,Translation,
    TranslationDetails,UeTemplate,UetTemplate,DialectTable,KOPF2,
    KOPF3,KOPF4,KopfStart,SEP,TextbausteinEnd,LT,RT,Template,
    TemplateAttr,TemplateAttrPlainText,LL,RL,Link,LinkAttr,RichLine,
    PlainText,CursiveText,ItemNo,BR,Comment,CommentStart,CommentEnd,
    Line,BadLine,EmptyLine,RestOfLine,Digit,OptDigit,Number,Letter,
    Word,Phrase,Space,COMMA,SEMICOLON,EOF,EOL,Dokument_0,Dokument_1,
    OtherLangEintrag_0,OtherLangEintrag_1,DeWortart_0,DeWortart_1,
    WortartBody_0,SubstantivAttributes_0,SubstantivAttributes_1,
    SubstantivAttributes_2,SubstantivAttribute_0,FlexionVariantList_0,
    FlexionVariantList_1,FlexionVariantList_2,FlexionVariantList_3,
    FlexionVariantList_4,FlexionVariantList_5,
    GenderTemplateArgument_0,GenderTemplateArgument_1,MiddleSection_0,
    MiddleSection_1,MeaningList_0,MeaningList_1,TranslationsSection_0,
    TranslationsSection_1,TranslationsSection_2,TranslationsSection_3,
    TranslationsTable_0,TranslationsTable_1,TranslationsTable_2,
    Translation_0,TranslationDetails_0,TranslationDetails_1,
    TranslationDetails_2,TranslationDetails_3,UeTemplate_0,
    TemplateAttr_0,TemplateAttr_1,TemplateAttr_2,
    TemplateAttrPlainText_0,TemplateAttrPlainText_1,
    TemplateAttrPlainText_2,Link_0,LinkAttr_0,LinkAttr_1,LinkAttr_2,
    RichLine_0,RichLine_1,RichLine_2,RichLine_3,Word_0,Phrase_0,EOL_0
  };
}
