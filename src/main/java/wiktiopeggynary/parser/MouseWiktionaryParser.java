//=========================================================================
//
//  This file was generated by Mouse 1.7 at 2017-09-21 10:36:50 GMT
//  from grammar
//    '/home/krzysiek/dev/projects/fiszki/wiktionary-parser/src/main/java/w
//    iktiopeggynary/parser/../../../resources/entry_grammar.txt'.
//
//=========================================================================

package wiktiopeggynary.parser;

import wiktiopeggynary.parser.mouse.Source;

public class MouseWiktionaryParser extends wiktiopeggynary.parser.mouse.ParserBase
{
  final WiktionarySemantics sem;
  
  //=======================================================================
  //
  //  Initialization
  //
  //=======================================================================
  //-------------------------------------------------------------------
  //  Constructor
  //-------------------------------------------------------------------
  public MouseWiktionaryParser()
    {
      sem = new WiktionarySemantics();
      sem.rule = this;
      super.sem = sem;
    }
  
  //-------------------------------------------------------------------
  //  Run the parser
  //-------------------------------------------------------------------
  public boolean parse(Source src)
    {
      super.init(src);
      sem.init();
      boolean result = Dokument();
      closeParser(result);
      return result;
    }
  
  //-------------------------------------------------------------------
  //  Get semantics
  //-------------------------------------------------------------------
  public WiktionarySemantics semantics()
    { return sem; }
  
  //=======================================================================
  //
  //  Parsing procedures
  //
  //=======================================================================
  //=====================================================================
  //  Dokument = (!KOPF2 Line)* Eintrag? ;
  //=====================================================================
  private boolean Dokument()
    {
      begin("Dokument");
      while (Dokument_0());
      Eintrag();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Dokument_0 = !KOPF2 Line
  //-------------------------------------------------------------------
  private boolean Dokument_0()
    {
      begin("");
      if (!Dokument_1()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Dokument_1 = !KOPF2
  //-------------------------------------------------------------------
  private boolean Dokument_1()
    {
      begin("","not KOPF2");
      if (KOPF2()) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  Eintrag = DeEintrag _*+ EOF / OldSpellingEintrag Line* EOF /
  //    AltSpellingEintrag Line* EOF / DeEintragWithErrors ;
  //=====================================================================
  private boolean Eintrag()
    {
      begin("Eintrag");
      if (Eintrag_0()) return accept();
      if (Eintrag_1()) return accept();
      if (Eintrag_2()) return accept();
      if (DeEintragWithErrors()) return accept();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  Eintrag_0 = DeEintrag _*+ EOF
  //-------------------------------------------------------------------
  private boolean Eintrag_0()
    {
      begin("");
      if (!DeEintrag()) return rejectInner();
      while (!EOF())
        if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Eintrag_1 = OldSpellingEintrag Line* EOF
  //-------------------------------------------------------------------
  private boolean Eintrag_1()
    {
      begin("");
      if (!OldSpellingEintrag()) return rejectInner();
      while (Line());
      if (!EOF()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Eintrag_2 = AltSpellingEintrag Line* EOF
  //-------------------------------------------------------------------
  private boolean Eintrag_2()
    {
      begin("");
      if (!AltSpellingEintrag()) return rejectInner();
      while (Line());
      if (!EOF()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  DeEintrag = DeSpracheKopf (!KOPF3 Line)* DeWortart+ ;
  //=====================================================================
  private boolean DeEintrag()
    {
      begin("DeEintrag");
      if (!DeSpracheKopf()) return reject();
      while (DeEintrag_0());
      if (!DeWortart()) return reject();
      while (DeWortart());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  DeEintrag_0 = !KOPF3 Line
  //-------------------------------------------------------------------
  private boolean DeEintrag_0()
    {
      begin("");
      if (!DeEintrag_1()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DeEintrag_1 = !KOPF3
  //-------------------------------------------------------------------
  private boolean DeEintrag_1()
    {
      begin("","not KOPF3");
      if (KOPF3()) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  DeEintragWithErrors = DeSpracheKopf _* EOF {DeEintragWithErrors} ;
  //=====================================================================
  private boolean DeEintragWithErrors()
    {
      begin("DeEintragWithErrors");
      if (!DeSpracheKopf()) return reject();
      while (next());
      if (!EOF()) return reject();
      sem.DeEintragWithErrors();
      return accept();
    }
  
  //=====================================================================
  //  OldSpellingEintrag = DeSpracheKopf Line*+ OldSpellingTemplate ;
  //=====================================================================
  private boolean OldSpellingEintrag()
    {
      begin("OldSpellingEintrag");
      if (!DeSpracheKopf()) return reject();
      while (!OldSpellingTemplate())
        if (!Line()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  OldSpellingTemplate = LT ("Alte Schreibweise" / "Schweizer und
  //    Liechtensteiner Schreibweise") SEP TextualTParam RestOfLine
  //    {OldSpellingTemplate} ;
  //=====================================================================
  private boolean OldSpellingTemplate()
    {
      begin("OldSpellingTemplate");
      if (!LT()) return reject();
      if (!next("Alte Schreibweise")
       && !next("Schweizer und Liechtensteiner Schreibweise")
         ) return reject();
      if (!SEP()) return reject();
      if (!TextualTParam()) return reject();
      if (!RestOfLine()) return reject();
      sem.OldSpellingTemplate();
      return accept();
    }
  
  //=====================================================================
  //  AltSpellingEintrag = DeSpracheKopf Line*+ AltSpellingTemplate ;
  //=====================================================================
  private boolean AltSpellingEintrag()
    {
      begin("AltSpellingEintrag");
      if (!DeSpracheKopf()) return reject();
      while (!AltSpellingTemplate())
        if (!Line()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  AltSpellingTemplate = "*" Space "Alternative Schreibweise" _*+ Link
  //    RestOfLine {AltSpellingTemplate_0} / LT "Alternative
  //    Schreibweisen" RT EOL ":" Link {AltSpellingTemplate_1} ;
  //=====================================================================
  private boolean AltSpellingTemplate()
    {
      begin("AltSpellingTemplate");
      if (AltSpellingTemplate_0())
      { sem.AltSpellingTemplate_0(); return accept(); }
      if (AltSpellingTemplate_1())
      { sem.AltSpellingTemplate_1(); return accept(); }
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  AltSpellingTemplate_0 = "*" Space "Alternative Schreibweise" _*+
  //    Link RestOfLine
  //-------------------------------------------------------------------
  private boolean AltSpellingTemplate_0()
    {
      begin("");
      if (!next('*')) return rejectInner();
      Space();
      if (!next("Alternative Schreibweise")) return rejectInner();
      while (!Link())
        if (!next()) return rejectInner();
      if (!RestOfLine()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  AltSpellingTemplate_1 = LT "Alternative Schreibweisen" RT EOL ":"
  //    Link
  //-------------------------------------------------------------------
  private boolean AltSpellingTemplate_1()
    {
      begin("");
      if (!LT()) return rejectInner();
      if (!next("Alternative Schreibweisen")) return rejectInner();
      if (!RT()) return rejectInner();
      if (!EOL()) return rejectInner();
      if (!next(':')) return rejectInner();
      if (!Link()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  DeSpracheKopf = KOPF2 Lemma "(" DeSpracheTemplate ")" Space KOPF2
  //    RestOfLine ;
  //=====================================================================
  private boolean DeSpracheKopf()
    {
      begin("DeSpracheKopf");
      if (!KOPF2()) return reject();
      if (!Lemma()) return reject();
      if (!next('(')) return reject();
      if (!DeSpracheTemplate()) return reject();
      if (!next(')')) return reject();
      Space();
      if (!KOPF2()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  DeSpracheTemplate = LT "Sprache" SEP "Deutsch" RT ;
  //=====================================================================
  private boolean DeSpracheTemplate()
    {
      begin("DeSpracheTemplate");
      if (!LT()) return reject();
      if (!next("Sprache")) return reject();
      if (!SEP()) return reject();
      if (!next("Deutsch")) return reject();
      if (!RT()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Lemma = (!(Space "(") _)+ Space {Lemma} ;
  //=====================================================================
  private boolean Lemma()
    {
      begin("Lemma");
      if (!Lemma_0()) return reject();
      while (Lemma_0());
      Space();
      sem.Lemma();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Lemma_0 = !(Space "(") _
  //-------------------------------------------------------------------
  private boolean Lemma_0()
    {
      begin("");
      if (!Lemma_1()) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  Lemma_1 = !(Space "(")
  //-------------------------------------------------------------------
  private boolean Lemma_1()
    {
      begin("","not Space \"(\"");
      if (Lemma_2()) return rejectPred();
      return acceptPred();
    }
  
  //-------------------------------------------------------------------
  //  Lemma_2 = Space "("
  //-------------------------------------------------------------------
  private boolean Lemma_2()
    {
      begin("");
      Space();
      if (!next('(')) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  DeWortart = (WortartKopf WortartBody / UnknownWortartKopf Line*) ;
  //=====================================================================
  private boolean DeWortart()
    {
      begin("DeWortart");
      if (!DeWortart_0()
       && !DeWortart_1()
         ) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  DeWortart_0 = WortartKopf WortartBody
  //-------------------------------------------------------------------
  private boolean DeWortart_0()
    {
      begin("");
      if (!WortartKopf()) return rejectInner();
      WortartBody();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  DeWortart_1 = UnknownWortartKopf Line*
  //-------------------------------------------------------------------
  private boolean DeWortart_1()
    {
      begin("");
      if (!UnknownWortartKopf()) return rejectInner();
      while (Line());
      return acceptInner();
    }
  
  //=====================================================================
  //  WortartKopf = SubstantivKopf {saveEintrag} ;
  //=====================================================================
  private boolean WortartKopf()
    {
      begin("WortartKopf");
      if (!SubstantivKopf()) return reject();
      sem.saveEintrag();
      return accept();
    }
  
  //=====================================================================
  //  WortartBody = MiddleSection TranslationsSection?
  //    ~{WortartBody_fail} ;
  //=====================================================================
  private boolean WortartBody()
    {
      begin("WortartBody");
      if (WortartBody_0()) return accept();
      sem.WortartBody_fail();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  WortartBody_0 = MiddleSection TranslationsSection?
  //-------------------------------------------------------------------
  private boolean WortartBody_0()
    {
      begin("");
      MiddleSection();
      TranslationsSection();
      return acceptInner();
    }
  
  //=====================================================================
  //  UnknownWortartKopf = KOPF3 WortartTemplate _*+ KOPF3 RestOfLine ;
  //=====================================================================
  private boolean UnknownWortartKopf()
    {
      begin("UnknownWortartKopf");
      if (!KOPF3()) return reject();
      if (!WortartTemplate()) return reject();
      while (!KOPF3())
        if (!next()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  WortartTemplate = LT "Wortart" SEP TParam SEP "Deutsch" RT
  //    {WortartTemplate} ;
  //=====================================================================
  private boolean WortartTemplate()
    {
      begin("WortartTemplate");
      if (!LT()) return reject();
      if (!next("Wortart")) return reject();
      if (!SEP()) return reject();
      TParam();
      if (!SEP()) return reject();
      if (!next("Deutsch")) return reject();
      if (!RT()) return reject();
      sem.WortartTemplate();
      return accept();
    }
  
  //=====================================================================
  //  SubstantivKopf = KOPF3 SubstantivTemplate Space
  //    SubstantivAttributes Space KOPF3 RestOfLine ;
  //=====================================================================
  private boolean SubstantivKopf()
    {
      begin("SubstantivKopf");
      if (!KOPF3()) return reject();
      if (!SubstantivTemplate()) return reject();
      Space();
      SubstantivAttributes();
      Space();
      if (!KOPF3()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  SubstantivTemplate = LT "Wortart" SEP "Substantiv" SEP "Deutsch" RT
  //    {createSubstantiv} ;
  //=====================================================================
  private boolean SubstantivTemplate()
    {
      begin("SubstantivTemplate");
      if (!LT()) return reject();
      if (!next("Wortart")) return reject();
      if (!SEP()) return reject();
      if (!next("Substantiv")) return reject();
      if (!SEP()) return reject();
      if (!next("Deutsch")) return reject();
      if (!RT()) return reject();
      sem.createSubstantiv();
      return accept();
    }
  
  //=====================================================================
  //  SubstantivAttributes = (","? Space SubstantivAttribute)*
  //    ~{SubstantivAttributes_fail} ;
  //=====================================================================
  private boolean SubstantivAttributes()
    {
      begin("SubstantivAttributes");
      if (SubstantivAttributes_0()) return accept();
      sem.SubstantivAttributes_fail();
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  SubstantivAttributes_0 = (","? Space SubstantivAttribute)*
  //-------------------------------------------------------------------
  private boolean SubstantivAttributes_0()
    {
      begin("");
      while (SubstantivAttributes_1());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  SubstantivAttributes_1 = ","? Space SubstantivAttribute
  //-------------------------------------------------------------------
  private boolean SubstantivAttributes_1()
    {
      begin("");
      next(',');
      Space();
      if (!SubstantivAttribute()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  SubstantivAttribute = Gender {substantivGender} / WortartTemplate
  //    {substantivWortart} / "''adjektivische Deklination" ","? "''"
  //    {substantivAdjDeklination} ;
  //=====================================================================
  private boolean SubstantivAttribute()
    {
      begin("SubstantivAttribute");
      if (Gender())
      { sem.substantivGender(); return accept(); }
      if (WortartTemplate())
      { sem.substantivWortart(); return accept(); }
      if (SubstantivAttribute_0())
      { sem.substantivAdjDeklination(); return accept(); }
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  SubstantivAttribute_0 = "''adjektivische Deklination" ","? "''"
  //-------------------------------------------------------------------
  private boolean SubstantivAttribute_0()
    {
      begin("");
      if (!next("''adjektivische Deklination")) return rejectInner();
      next(',');
      if (!next("''")) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  FlexionTable = FlexionTableKopf FlexionForm* RT RestOfLine ;
  //=====================================================================
  private boolean FlexionTable()
    {
      begin("FlexionTable");
      if (!FlexionTableKopf()) return reject();
      while (FlexionForm());
      if (!RT()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  FlexionTableKopf = LT "Deutsch Substantiv Übersicht" Space
  //    RestOfLine ;
  //=====================================================================
  private boolean FlexionTableKopf()
    {
      begin("FlexionTableKopf");
      if (!LT()) return reject();
      if (!next("Deutsch Substantiv \u00dcbersicht")) return reject();
      Space();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  FlexionForm = SEP (Genus / NomSg / NomPl / GenSg / GenPl / DatSg /
  //    DatPl / AkkSg / AkkPl / BadLine) ;
  //=====================================================================
  private boolean FlexionForm()
    {
      begin("FlexionForm");
      if (!SEP()) return reject();
      if (!Genus()
       && !NomSg()
       && !NomPl()
       && !GenSg()
       && !GenPl()
       && !DatSg()
       && !DatPl()
       && !AkkSg()
       && !AkkPl()
       && !BadLine()
         ) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Genus = "Genus" (Space Digit)? "=" ([mnfu0x] / "pl") EOL {addGenus}
  //    ;
  //=====================================================================
  private boolean Genus()
    {
      begin("Genus");
      if (!next("Genus")) return reject();
      Genus_0();
      if (!next('=')) return reject();
      if (!nextIn("mnfu0x")
       && !next("pl")
         ) return reject();
      if (!EOL()) return reject();
      sem.addGenus();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Genus_0 = Space Digit
  //-------------------------------------------------------------------
  private boolean Genus_0()
    {
      begin("");
      Space();
      if (!Digit()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  NomSg = "Nominativ Singular" Space OptDigit "*"? Space "=" Phrase
  //    EOL {addNomSg} ;
  //=====================================================================
  private boolean NomSg()
    {
      begin("NomSg");
      if (!next("Nominativ Singular")) return reject();
      Space();
      OptDigit();
      next('*');
      Space();
      if (!next('=')) return reject();
      if (!Phrase()) return reject();
      if (!EOL()) return reject();
      sem.addNomSg();
      return accept();
    }
  
  //=====================================================================
  //  NomPl = "Nominativ Plural" Space OptDigit "*"? Space "=" Phrase EOL
  //    {addNomPl} ;
  //=====================================================================
  private boolean NomPl()
    {
      begin("NomPl");
      if (!next("Nominativ Plural")) return reject();
      Space();
      OptDigit();
      next('*');
      Space();
      if (!next('=')) return reject();
      if (!Phrase()) return reject();
      if (!EOL()) return reject();
      sem.addNomPl();
      return accept();
    }
  
  //=====================================================================
  //  GenSg = "Genitiv Singular" Space OptDigit "*"? Space "=" Phrase EOL
  //    {addGenSg} ;
  //=====================================================================
  private boolean GenSg()
    {
      begin("GenSg");
      if (!next("Genitiv Singular")) return reject();
      Space();
      OptDigit();
      next('*');
      Space();
      if (!next('=')) return reject();
      if (!Phrase()) return reject();
      if (!EOL()) return reject();
      sem.addGenSg();
      return accept();
    }
  
  //=====================================================================
  //  GenPl = "Genitiv Plural" Space OptDigit "*"? Space "=" Phrase EOL
  //    {addGenPl} ;
  //=====================================================================
  private boolean GenPl()
    {
      begin("GenPl");
      if (!next("Genitiv Plural")) return reject();
      Space();
      OptDigit();
      next('*');
      Space();
      if (!next('=')) return reject();
      if (!Phrase()) return reject();
      if (!EOL()) return reject();
      sem.addGenPl();
      return accept();
    }
  
  //=====================================================================
  //  DatSg = "Dativ Singular" Space OptDigit "*"? Space "=" Phrase EOL
  //    {addDatSg} ;
  //=====================================================================
  private boolean DatSg()
    {
      begin("DatSg");
      if (!next("Dativ Singular")) return reject();
      Space();
      OptDigit();
      next('*');
      Space();
      if (!next('=')) return reject();
      if (!Phrase()) return reject();
      if (!EOL()) return reject();
      sem.addDatSg();
      return accept();
    }
  
  //=====================================================================
  //  DatPl = "Dativ Plural" Space OptDigit "*"? Space "=" Phrase EOL
  //    {addDatPl} ;
  //=====================================================================
  private boolean DatPl()
    {
      begin("DatPl");
      if (!next("Dativ Plural")) return reject();
      Space();
      OptDigit();
      next('*');
      Space();
      if (!next('=')) return reject();
      if (!Phrase()) return reject();
      if (!EOL()) return reject();
      sem.addDatPl();
      return accept();
    }
  
  //=====================================================================
  //  AkkSg = "Akkusativ Singular" Space OptDigit "*"? Space "=" Phrase
  //    EOL {addAkkSg} ;
  //=====================================================================
  private boolean AkkSg()
    {
      begin("AkkSg");
      if (!next("Akkusativ Singular")) return reject();
      Space();
      OptDigit();
      next('*');
      Space();
      if (!next('=')) return reject();
      if (!Phrase()) return reject();
      if (!EOL()) return reject();
      sem.addAkkSg();
      return accept();
    }
  
  //=====================================================================
  //  AkkPl = "Akkusativ Plural" Space OptDigit "*"? Space "=" Phrase EOL
  //    {addAkkPl} ;
  //=====================================================================
  private boolean AkkPl()
    {
      begin("AkkPl");
      if (!next("Akkusativ Plural")) return reject();
      Space();
      OptDigit();
      next('*');
      Space();
      if (!next('=')) return reject();
      if (!Phrase()) return reject();
      if (!EOL()) return reject();
      sem.addAkkPl();
      return accept();
    }
  
  //=====================================================================
  //  Gender = LT GenderTemplateArgument "."? RT Space {Gender} ;
  //=====================================================================
  private boolean Gender()
    {
      begin("Gender");
      if (!LT()) return reject();
      if (!GenderTemplateArgument()) return reject();
      next('.');
      if (!RT()) return reject();
      Space();
      sem.Gender();
      return accept();
    }
  
  //=====================================================================
  //  GenderTemplateArgument = [mnfu]+ {GenderTemplateArgument} ;
  //=====================================================================
  private boolean GenderTemplateArgument()
    {
      begin("GenderTemplateArgument");
      if (!nextIn("mnfu")) return reject();
      while (nextIn("mnfu"));
      sem.GenderTemplateArgument();
      return accept();
    }
  
  //=====================================================================
  //  MiddleSection = (!TranslationsKopf (FlexionTable / Line))* ;
  //=====================================================================
  private boolean MiddleSection()
    {
      begin("MiddleSection");
      while (MiddleSection_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  MiddleSection_0 = !TranslationsKopf (FlexionTable / Line)
  //-------------------------------------------------------------------
  private boolean MiddleSection_0()
    {
      begin("");
      if (!MiddleSection_1()) return rejectInner();
      if (!FlexionTable()
       && !Line()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  MiddleSection_1 = !TranslationsKopf
  //-------------------------------------------------------------------
  private boolean MiddleSection_1()
    {
      begin("","not TranslationsKopf");
      if (TranslationsKopf()) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  MeaningsTextbaustein = MeaningsKopf MeaningList ;
  //=====================================================================
  private boolean MeaningsTextbaustein()
    {
      begin("MeaningsTextbaustein");
      if (!MeaningsKopf()) return reject();
      MeaningList();
      return accept();
    }
  
  //=====================================================================
  //  MeaningsKopf = LT "Bedeutungen" RT RestOfLine ;
  //=====================================================================
  private boolean MeaningsKopf()
    {
      begin("MeaningsKopf");
      if (!LT()) return reject();
      if (!next("Bedeutungen")) return reject();
      if (!RT()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  MeaningList = (!TextbausteinEnd (Meaning / Line))* ;
  //=====================================================================
  private boolean MeaningList()
    {
      begin("MeaningList");
      while (MeaningList_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  MeaningList_0 = !TextbausteinEnd (Meaning / Line)
  //-------------------------------------------------------------------
  private boolean MeaningList_0()
    {
      begin("");
      if (!MeaningList_1()) return rejectInner();
      if (!Meaning()
       && !Line()
         ) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  MeaningList_1 = !TextbausteinEnd
  //-------------------------------------------------------------------
  private boolean MeaningList_1()
    {
      begin("","not TextbausteinEnd");
      if (TextbausteinEnd()) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  Meaning = MeaningLvl RichTextComponent++ EOL {Meaning} ;
  //=====================================================================
  private boolean Meaning()
    {
      begin("Meaning");
      if (!MeaningLvl()) return reject();
      if (EOL()) return reject();
      do if (!RichTextComponent()) return reject();
        while (!EOL());
      sem.Meaning();
      return accept();
    }
  
  //=====================================================================
  //  MeaningLvl = ":"+ (ItemNo / "*") ;
  //=====================================================================
  private boolean MeaningLvl()
    {
      begin("MeaningLvl");
      if (!next(':')) return reject();
      while (next(':'));
      if (!ItemNo()
       && !next('*')
         ) return reject();
      return accept();
    }
  
  //=====================================================================
  //  TranslationsSection = TranslationsKopf (!TranslationsTableKopf
  //    Line)* TranslationsTable (!KopfStart Line)* ;
  //=====================================================================
  private boolean TranslationsSection()
    {
      begin("TranslationsSection");
      if (!TranslationsKopf()) return reject();
      while (TranslationsSection_0());
      if (!TranslationsTable()) return reject();
      while (TranslationsSection_1());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsSection_0 = !TranslationsTableKopf Line
  //-------------------------------------------------------------------
  private boolean TranslationsSection_0()
    {
      begin("");
      if (!TranslationsSection_2()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsSection_1 = !KopfStart Line
  //-------------------------------------------------------------------
  private boolean TranslationsSection_1()
    {
      begin("");
      if (!TranslationsSection_3()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsSection_2 = !TranslationsTableKopf
  //-------------------------------------------------------------------
  private boolean TranslationsSection_2()
    {
      begin("","not TranslationsTableKopf");
      if (TranslationsTableKopf()) return rejectPred();
      return acceptPred();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsSection_3 = !KopfStart
  //-------------------------------------------------------------------
  private boolean TranslationsSection_3()
    {
      begin("","not KopfStart");
      if (KopfStart()) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  TranslationsKopf = KOPF4 LT "Übersetzungen" RT Space KOPF4
  //    RestOfLine ;
  //=====================================================================
  private boolean TranslationsKopf()
    {
      begin("TranslationsKopf");
      if (!KOPF4()) return reject();
      if (!LT()) return reject();
      if (!next("\u00dcbersetzungen")) return reject();
      if (!RT()) return reject();
      Space();
      if (!KOPF4()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  TranslationsTable = TranslationsTableKopf (LangTranslations /
  //    DialectTable / !RT Line)*+ RT RestOfLine ;
  //=====================================================================
  private boolean TranslationsTable()
    {
      begin("TranslationsTable");
      if (!TranslationsTableKopf()) return reject();
      while (!RT())
        if (!TranslationsTable_0()) return reject();
      if (!RestOfLine()) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsTable_0 = LangTranslations / DialectTable / !RT Line
  //-------------------------------------------------------------------
  private boolean TranslationsTable_0()
    {
      begin("");
      if (LangTranslations()) return acceptInner();
      if (DialectTable()) return acceptInner();
      if (TranslationsTable_1()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsTable_1 = !RT Line
  //-------------------------------------------------------------------
  private boolean TranslationsTable_1()
    {
      begin("");
      if (!TranslationsTable_2()) return rejectInner();
      if (!Line()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationsTable_2 = !RT
  //-------------------------------------------------------------------
  private boolean TranslationsTable_2()
    {
      begin("","not RT");
      if (RT()) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  TranslationsTableKopf = LT "Ü-Tabelle" Line ;
  //=====================================================================
  private boolean TranslationsTableKopf()
    {
      begin("TranslationsTableKopf");
      if (!LT()) return reject();
      if (!next("\u00dc-Tabelle")) return reject();
      if (!Line()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  LangTranslations = LangLvl Lang ":" Space TranslationMeaning*
  //    RestOfLine {addTranslationsForLanguage} ;
  //=====================================================================
  private boolean LangTranslations()
    {
      begin("LangTranslations");
      if (!LangLvl()) return reject();
      if (!Lang()) return reject();
      if (!next(':')) return reject();
      Space();
      while (TranslationMeaning());
      if (!RestOfLine()) return reject();
      sem.addTranslationsForLanguage();
      return accept();
    }
  
  //=====================================================================
  //  LangLvl = "*"+ ;
  //=====================================================================
  private boolean LangLvl()
    {
      begin("LangLvl");
      if (!next('*')) return reject();
      while (next('*'));
      return accept();
    }
  
  //=====================================================================
  //  Lang = LT Phrase RT {Lang} ;
  //=====================================================================
  private boolean Lang()
    {
      begin("Lang");
      if (!LT()) return reject();
      if (!Phrase()) return reject();
      if (!RT()) return reject();
      sem.Lang();
      return accept();
    }
  
  //=====================================================================
  //  TranslationMeaning = ItemNo Translation+ {TranslationMeaning} ;
  //=====================================================================
  private boolean TranslationMeaning()
    {
      begin("TranslationMeaning");
      if (!ItemNo()) return reject();
      if (!Translation()) return reject();
      while (Translation());
      sem.TranslationMeaning();
      return accept();
    }
  
  //=====================================================================
  //  Translation = TranslationDetails (UeTemplate / UetTemplate) Gender?
  //    TranslationDetails (COMMA / SEMICOLON)? Space {Translation} ;
  //=====================================================================
  private boolean Translation()
    {
      begin("Translation");
      TranslationDetails();
      if (!UeTemplate()
       && !UetTemplate()
         ) return reject();
      Gender();
      TranslationDetails();
      Translation_0();
      Space();
      sem.Translation();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Translation_0 = COMMA / SEMICOLON
  //-------------------------------------------------------------------
  private boolean Translation_0()
    {
      begin("");
      if (COMMA()) return acceptInner();
      if (SEMICOLON()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  TranslationDetails = (CursiveText / Link / !(ItemNo / UeTemplate /
  //    UetTemplate / COMMA / SEMICOLON / EOL) _)* (COMMA / SEMICOLON)?
  //    ;
  //=====================================================================
  private boolean TranslationDetails()
    {
      begin("TranslationDetails");
      while (TranslationDetails_0());
      Translation_0();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TranslationDetails_0 = CursiveText / Link / !(ItemNo / UeTemplate
  //    / UetTemplate / COMMA / SEMICOLON / EOL) _
  //-------------------------------------------------------------------
  private boolean TranslationDetails_0()
    {
      begin("");
      if (CursiveText()) return acceptInner();
      if (Link()) return acceptInner();
      if (TranslationDetails_1()) return acceptInner();
      return rejectInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationDetails_1 = !(ItemNo / UeTemplate / UetTemplate /
  //    COMMA / SEMICOLON / EOL) _
  //-------------------------------------------------------------------
  private boolean TranslationDetails_1()
    {
      begin("");
      if (!TranslationDetails_2()) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TranslationDetails_2 = !(ItemNo / UeTemplate / UetTemplate /
  //    COMMA / SEMICOLON / EOL)
  //-------------------------------------------------------------------
  private boolean TranslationDetails_2()
    {
      begin("","not ItemNo / UeTemplate / UetTemplate / COMMA / SEMICOLON / EOL");
      if (TranslationDetails_3()) return rejectPred();
      return acceptPred();
    }
  
  //-------------------------------------------------------------------
  //  TranslationDetails_3 = ItemNo / UeTemplate / UetTemplate / COMMA
  //    / SEMICOLON / EOL
  //-------------------------------------------------------------------
  private boolean TranslationDetails_3()
    {
      begin("");
      if (ItemNo()) return acceptInner();
      if (UeTemplate()) return acceptInner();
      if (UetTemplate()) return acceptInner();
      if (COMMA()) return acceptInner();
      if (SEMICOLON()) return acceptInner();
      if (EOL()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  UeTemplate = LT ("Ü" / "Ü?") SEP TParam SEP TParam (SEP TParam)?
  //    (SEP TParam)? RT Space {UeTemplate} ;
  //=====================================================================
  private boolean UeTemplate()
    {
      begin("UeTemplate");
      if (!LT()) return reject();
      if (!next('\u00dc')
       && !next("\u00dc?")
         ) return reject();
      if (!SEP()) return reject();
      TParam();
      if (!SEP()) return reject();
      TParam();
      UeTemplate_0();
      UeTemplate_0();
      if (!RT()) return reject();
      Space();
      sem.UeTemplate();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  UeTemplate_0 = SEP TParam
  //-------------------------------------------------------------------
  private boolean UeTemplate_0()
    {
      begin("");
      if (!SEP()) return rejectInner();
      TParam();
      return acceptInner();
    }
  
  //=====================================================================
  //  UetTemplate = LT ("Üt" / "Üt?") SEP TParam SEP TParam SEP TParam
  //    (SEP TParam)? (SEP TParam)? RT Space {UetTemplate} ;
  //=====================================================================
  private boolean UetTemplate()
    {
      begin("UetTemplate");
      if (!LT()) return reject();
      if (!next("\u00dct")
       && !next("\u00dct?")
         ) return reject();
      if (!SEP()) return reject();
      TParam();
      if (!SEP()) return reject();
      TParam();
      if (!SEP()) return reject();
      TParam();
      UeTemplate_0();
      UeTemplate_0();
      if (!RT()) return reject();
      Space();
      sem.UetTemplate();
      return accept();
    }
  
  //=====================================================================
  //  DialectTable = "|Dialekttabelle=" RestOfLine (!RT Line)* ;
  //=====================================================================
  private boolean DialectTable()
    {
      begin("DialectTable");
      if (!next("|Dialekttabelle=")) return reject();
      if (!RestOfLine()) return reject();
      while (TranslationsTable_1());
      return accept();
    }
  
  //=====================================================================
  //  KOPF2 = "==" Space ;
  //=====================================================================
  private boolean KOPF2()
    {
      begin("KOPF2");
      if (!next("==")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  KOPF3 = "===" Space ;
  //=====================================================================
  private boolean KOPF3()
    {
      begin("KOPF3");
      if (!next("===")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  KOPF4 = "====" Space ;
  //=====================================================================
  private boolean KOPF4()
    {
      begin("KOPF4");
      if (!next("====")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  KopfStart = "==" ;
  //=====================================================================
  private boolean KopfStart()
    {
      begin("KopfStart");
      if (!next("==")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  SEP = Space "|" Space ;
  //=====================================================================
  private boolean SEP()
    {
      begin("SEP");
      Space();
      if (!next('|')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  TextbausteinEnd = LT / KopfStart / EOF ;
  //=====================================================================
  private boolean TextbausteinEnd()
    {
      begin("TextbausteinEnd");
      if (LT()) return accept();
      if (KopfStart()) return accept();
      if (EOF()) return accept();
      return reject();
    }
  
  //=====================================================================
  //  RichTextComponent = Link {RichTextComponent_0} / CursiveText
  //    {RichTextComponent_1} / Template {RichTextComponent_2} / !EOL _
  //    {RichTextComponent_3} ;
  //=====================================================================
  private boolean RichTextComponent()
    {
      begin("RichTextComponent");
      if (Link())
      { sem.RichTextComponent_0(); return accept(); }
      if (CursiveText())
      { sem.RichTextComponent_1(); return accept(); }
      if (Template())
      { sem.RichTextComponent_2(); return accept(); }
      if (RichTextComponent_0())
      { sem.RichTextComponent_3(); return accept(); }
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  RichTextComponent_0 = !EOL _
  //-------------------------------------------------------------------
  private boolean RichTextComponent_0()
    {
      begin("");
      if (!RichTextComponent_1()) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  RichTextComponent_1 = !EOL
  //-------------------------------------------------------------------
  private boolean RichTextComponent_1()
    {
      begin("","not EOL");
      if (EOL()) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  LL = "[[" ;
  //=====================================================================
  private boolean LL()
    {
      begin("LL");
      if (!next("[[")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  RL = "]]" ;
  //=====================================================================
  private boolean RL()
    {
      begin("RL");
      if (!next("]]")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Link = LL LinkAttr (SEP LinkAttr)? RL {Link} ;
  //=====================================================================
  private boolean Link()
    {
      begin("Link");
      if (!LL()) return reject();
      if (!LinkAttr()) return reject();
      Link_0();
      if (!RL()) return reject();
      sem.Link();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Link_0 = SEP LinkAttr
  //-------------------------------------------------------------------
  private boolean Link_0()
    {
      begin("");
      if (!SEP()) return rejectInner();
      if (!LinkAttr()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  LinkAttr = (!(SEP / RL) _)+ ;
  //=====================================================================
  private boolean LinkAttr()
    {
      begin("LinkAttr");
      if (!LinkAttr_0()) return reject();
      while (LinkAttr_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  LinkAttr_0 = !(SEP / RL) _
  //-------------------------------------------------------------------
  private boolean LinkAttr_0()
    {
      begin("");
      if (!LinkAttr_1()) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  LinkAttr_1 = !(SEP / RL)
  //-------------------------------------------------------------------
  private boolean LinkAttr_1()
    {
      begin("","not SEP / RL");
      if (LinkAttr_2()) return rejectPred();
      return acceptPred();
    }
  
  //-------------------------------------------------------------------
  //  LinkAttr_2 = SEP / RL
  //-------------------------------------------------------------------
  private boolean LinkAttr_2()
    {
      begin("");
      if (SEP()) return acceptInner();
      if (RL()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  CursiveText = "''" RichTextComponent*+ "''" {CursiveText} ;
  //=====================================================================
  private boolean CursiveText()
    {
      begin("CursiveText");
      if (!next("''")) return reject();
      while (!next("''"))
        if (!RichTextComponent()) return reject();
      sem.CursiveText();
      return accept();
    }
  
  //=====================================================================
  //  LT = "{{" Space ;
  //=====================================================================
  private boolean LT()
    {
      begin("LT");
      if (!next("{{")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  RT = Space "}}" ;
  //=====================================================================
  private boolean RT()
    {
      begin("RT");
      Space();
      if (!next("}}")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Template = LT TName (SEP TParam)* RT {Template} ;
  //=====================================================================
  private boolean Template()
    {
      begin("Template");
      if (!LT()) return reject();
      if (!TName()) return reject();
      while (UeTemplate_0());
      if (!RT()) return reject();
      sem.Template();
      return accept();
    }
  
  //=====================================================================
  //  TName = (!(SEP / RT) _)+ ;
  //=====================================================================
  private boolean TName()
    {
      begin("TName");
      if (!TName_0()) return reject();
      while (TName_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TName_0 = !(SEP / RT) _
  //-------------------------------------------------------------------
  private boolean TName_0()
    {
      begin("");
      if (!TName_1()) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TName_1 = !(SEP / RT)
  //-------------------------------------------------------------------
  private boolean TName_1()
    {
      begin("","not SEP / RT");
      if (TName_2()) return rejectPred();
      return acceptPred();
    }
  
  //-------------------------------------------------------------------
  //  TName_2 = SEP / RT
  //-------------------------------------------------------------------
  private boolean TName_2()
    {
      begin("");
      if (SEP()) return acceptInner();
      if (RT()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  TParam = Number EQ (!(SEP / RT) RichTextComponent)* {TParam_0} /
  //    TParamName EQ (!(SEP / RT) RichTextComponent)* {TParam_1} /
  //    (!(SEP / RT) RichTextComponent)* {TParam_2} ;
  //=====================================================================
  private boolean TParam()
    {
      begin("TParam");
      if (TParam_0())
      { sem.TParam_0(); return accept(); }
      if (TParam_1())
      { sem.TParam_1(); return accept(); }
      if (TParam_2())
      { sem.TParam_2(); return accept(); }
      return reject();
    }
  
  //-------------------------------------------------------------------
  //  TParam_0 = Number EQ (!(SEP / RT) RichTextComponent)*
  //-------------------------------------------------------------------
  private boolean TParam_0()
    {
      begin("");
      if (!Number()) return rejectInner();
      if (!EQ()) return rejectInner();
      while (TParam_3());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TParam_1 = TParamName EQ (!(SEP / RT) RichTextComponent)*
  //-------------------------------------------------------------------
  private boolean TParam_1()
    {
      begin("");
      if (!TParamName()) return rejectInner();
      if (!EQ()) return rejectInner();
      while (TParam_3());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TParam_2 = (!(SEP / RT) RichTextComponent)*
  //-------------------------------------------------------------------
  private boolean TParam_2()
    {
      begin("");
      while (TParam_3());
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TParam_3 = !(SEP / RT) RichTextComponent
  //-------------------------------------------------------------------
  private boolean TParam_3()
    {
      begin("");
      if (!TName_1()) return rejectInner();
      if (!RichTextComponent()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  TParamName = (!(SEP / RT / EQ) _)+ ;
  //=====================================================================
  private boolean TParamName()
    {
      begin("TParamName");
      if (!TParamName_0()) return reject();
      while (TParamName_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  TParamName_0 = !(SEP / RT / EQ) _
  //-------------------------------------------------------------------
  private boolean TParamName_0()
    {
      begin("");
      if (!TParamName_1()) return rejectInner();
      if (!next()) return rejectInner();
      return acceptInner();
    }
  
  //-------------------------------------------------------------------
  //  TParamName_1 = !(SEP / RT / EQ)
  //-------------------------------------------------------------------
  private boolean TParamName_1()
    {
      begin("","not SEP / RT / EQ");
      if (TParamName_2()) return rejectPred();
      return acceptPred();
    }
  
  //-------------------------------------------------------------------
  //  TParamName_2 = SEP / RT / EQ
  //-------------------------------------------------------------------
  private boolean TParamName_2()
    {
      begin("");
      if (SEP()) return acceptInner();
      if (RT()) return acceptInner();
      if (EQ()) return acceptInner();
      return rejectInner();
    }
  
  //=====================================================================
  //  TextualTParam = (!(SEP / RT) _)+ ;
  //=====================================================================
  private boolean TextualTParam()
    {
      begin("TextualTParam");
      if (!TName_0()) return reject();
      while (TName_0());
      return accept();
    }
  
  //=====================================================================
  //  ItemNo = "[" _++ "]" Space {ItemNo} ;
  //=====================================================================
  private boolean ItemNo()
    {
      begin("ItemNo");
      if (!next('[')) return reject();
      if (next(']')) return reject();
      do if (!next()) return reject();
        while (!next(']'));
      Space();
      sem.ItemNo();
      return accept();
    }
  
  //=====================================================================
  //  BR = "<br" Space "/>" ;
  //=====================================================================
  private boolean BR()
    {
      begin("BR");
      if (!next("<br")) return reject();
      Space();
      if (!next("/>")) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Comment = CommentStart _++ CommentEnd Space ;
  //=====================================================================
  private boolean Comment()
    {
      begin("Comment");
      if (!CommentStart()) return reject();
      if (CommentEnd()) return reject();
      do if (!next()) return reject();
        while (!CommentEnd());
      Space();
      return accept();
    }
  
  //=====================================================================
  //  CommentStart = "<!--" Space ;
  //=====================================================================
  private boolean CommentStart()
    {
      begin("CommentStart");
      if (!next("<!--")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  CommentEnd = "-->" Space ;
  //=====================================================================
  private boolean CommentEnd()
    {
      begin("CommentEnd");
      if (!next("-->")) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  Line = _*+ EOL ;
  //=====================================================================
  private boolean Line()
    {
      begin("Line");
      while (!EOL())
        if (!next()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  BadLine = _++ EOL ;
  //=====================================================================
  private boolean BadLine()
    {
      begin("BadLine");
      if (EOL()) return reject();
      do if (!next()) return reject();
        while (!EOL());
      return accept();
    }
  
  //=====================================================================
  //  RestOfLine = _*+ EOL ;
  //=====================================================================
  private boolean RestOfLine()
    {
      begin("RestOfLine");
      while (!EOL())
        if (!next()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  Digit = [0-9] ;
  //=====================================================================
  private boolean Digit()
    {
      begin("Digit");
      if (!nextIn('0','9')) return reject();
      return accept();
    }
  
  //=====================================================================
  //  OptDigit = Digit? ;
  //=====================================================================
  private boolean OptDigit()
    {
      begin("OptDigit");
      Digit();
      return accept();
    }
  
  //=====================================================================
  //  Number = Digit+ ;
  //=====================================================================
  private boolean Number()
    {
      begin("Number");
      if (!Digit()) return reject();
      while (Digit());
      return accept();
    }
  
  //=====================================================================
  //  Letter = !Digit ^[!@#$%^&*()_-+=[]{};:'"\|<>,./?`~\n\t ] ;
  //=====================================================================
  private boolean Letter()
    {
      begin("Letter");
      if (!Letter_0()) return reject();
      if (!nextNotIn("!@#$%^&*()_-+=[]{};:'\"\\|<>,./?`~\n\t ")) return reject();
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Letter_0 = !Digit
  //-------------------------------------------------------------------
  private boolean Letter_0()
    {
      begin("","not Digit");
      if (Digit()) return rejectPred();
      return acceptPred();
    }
  
  //=====================================================================
  //  Word = Letter+ ("-" Letter+)* ;
  //=====================================================================
  private boolean Word()
    {
      begin("Word");
      if (!Letter()) return reject();
      while (Letter());
      while (Word_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Word_0 = "-" Letter+
  //-------------------------------------------------------------------
  private boolean Word_0()
    {
      begin("");
      if (!next('-')) return rejectInner();
      if (!Letter()) return rejectInner();
      while (Letter());
      return acceptInner();
    }
  
  //=====================================================================
  //  Phrase = Word (Space Word)* ;
  //=====================================================================
  private boolean Phrase()
    {
      begin("Phrase");
      if (!Word()) return reject();
      while (Phrase_0());
      return accept();
    }
  
  //-------------------------------------------------------------------
  //  Phrase_0 = Space Word
  //-------------------------------------------------------------------
  private boolean Phrase_0()
    {
      begin("");
      Space();
      if (!Word()) return rejectInner();
      return acceptInner();
    }
  
  //=====================================================================
  //  Space = " "* ;
  //=====================================================================
  private boolean Space()
    {
      begin("Space");
      while (next(' '));
      return accept();
    }
  
  //=====================================================================
  //  COMMA = "," Space ;
  //=====================================================================
  private boolean COMMA()
    {
      begin("COMMA");
      if (!next(',')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  SEMICOLON = ";" Space ;
  //=====================================================================
  private boolean SEMICOLON()
    {
      begin("SEMICOLON");
      if (!next(';')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  EQ = Space "=" Space ;
  //=====================================================================
  private boolean EQ()
    {
      begin("EQ");
      Space();
      if (!next('=')) return reject();
      Space();
      return accept();
    }
  
  //=====================================================================
  //  EOF = !_ ;
  //=====================================================================
  private boolean EOF()
    {
      begin("EOF");
      if (!aheadNot()) return reject();
      return accept();
    }
  
  //=====================================================================
  //  EOL = [\r\n]+ ;
  //=====================================================================
  private boolean EOL()
    {
      begin("EOL");
      if (!nextIn("\r\n")) return reject();
      while (nextIn("\r\n"));
      return accept();
    }
  
}
